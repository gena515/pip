SVN-fs-dump-format-version: 2

UUID: 8c8ae027-ef23-483d-802b-e445908bb8c5

Revision-number: 0
Prop-content-length: 56
Content-length: 56

K 8
svn:date
V 27
2010-07-02T01:15:48.004771Z
PROPS-END

Revision-number: 1
Prop-content-length: 122
Content-length: 122

K 7
svn:log
V 23
created branches folder
K 10
svn:author
V 4
hugo
K 8
svn:date
V 27
2010-07-02T01:20:13.566306Z
PROPS-END

Node-path: branches
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 2
Prop-content-length: 112
Content-length: 112

K 7
svn:log
V 13
added tag 0.1
K 10
svn:author
V 4
hugo
K 8
svn:date
V 27
2010-07-02T01:21:59.805219Z
PROPS-END

Node-path: tags
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Node-path: tags/0.1
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Node-path: tags/0.1/docs
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Node-path: tags/0.1/docs/index.txt
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 2780
Text-content-md5: 499aebbe9096ab58531d101be20a3e7f
Text-content-sha1: 89073085bba5ef05033e394e61a08e9f009f8681
Content-length: 2790

PROPS-END
INITools
--------

.. contents::

Intro & Status
--------------

INITools is a variety of modules for manipulating ``.ini``-style
files.  This is similar to `ConfigParser
<http://python.org/doc/current/lib/module-ConfigParser.html>`_, only
easier to build on than that library.

I'm not (very) actively developing this library, though I do use it
from time to time.  Anyone interested in doing something with it
should feel free to take it in whatever direction they find
interesting.  You can contact me at ianb@colorstudy.com

Overview
--------

A whirlwind tour of the modules:

``iniparser``:
    The most basic module, this is a simple parser for ``.ini``-style
    files.  You subclass the parser and build your objects as the file
    is parsed.  See ``initools.iniparser.BasicParser`` for a minimal
    example.

``configwrapper``:
    This offers a simple ``Config`` object that takes a single
    filename as an argument, and provides a simple interface to that
    file.  The closest thing here to ``ConfigParser``, I guess.

``lazyiniparser``:
    An ini parser that keeps complete track of the files it draws
    from, including order, filename/line number, and comments.  It can
    be used for systems that support round-tripping (reading and
    writing files).

``inischema``:
    A thought experiment, mostly.  Supports a class-based schema
    definition, and reads files matching them against the definition.
    Not terribly advanced.  It would be more interesting if it used
    `FormEncode <http://formencode.org>`_ for schemas, or maybe
    something based on (or similar to) `optparse
    <http://python.org/doc/current/lib/module-optparse.html>`_.  A
    config-file compliment to ``optparse`` would be generally useful,
    but probably would be based more on ``iniparser`` or
    ``lazyiniparser``.

``nested``:
    A nested dictionary-like object.  Lets you fold several
    dictionaries into a single view, including nested dictionaries.

``lazyloader``:
    The fanciest and most complicated of the modules.  This is where
    it seemed to get out of control (especially combined as it is with
    ``nested``).  This supports loading several files, doing
    conversion with source tracking, parsing the keys and sections to
    create highly nested structures, and folding a configuration back
    onto itself (for context-sensitive configuration).

    This is complex enough that it becomes necessary to debug your
    configuration files, which sucks.

Documentation
-------------

See the `pudge generated documentation <module-index.html>`_.

Future
------

I don't have any particular plans, but if you do that's cool.  The
``optparse`` thing would be cool.

Other Options
-------------

See http://wiki.python.org/moin/ConfigParserShootout



Node-path: tags/0.1/initools
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Node-path: tags/0.1/initools/__init__.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 2
Text-content-md5: 552dacb15f2019c8f3f74c55befa242c
Text-content-sha1: 9762053d4defb8be822cb0957983a6b8796976d6
Content-length: 12

PROPS-END
#


Node-path: tags/0.1/initools/configwrapper.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 8346
Text-content-md5: 930a838db16944aa4e57cff9ca46143a
Text-content-sha1: fae23bbdd312d986c38c1d6837528587d4db79b7
Content-length: 8356

PROPS-END
import os
import iniparser

class _ConfigParser(iniparser.INIParser):

    """
    An internal subclass of the abstract ini parser, which saves
    everything into one dictionary.
    """

    def __init__(self, allow_empty_sections=True):
        self.allow_empty_sections = allow_empty_sections
        iniparser.INIParser.__init__(self)

    def reset(self):
        self.data = {}
        self.key_order = {}
        self.section_order = []
        iniparser.INIParser.reset(self)

    def assignment(self, name, content):
        section = self.data.setdefault(self.section, {})
        name = clean_name(name)
        section.setdefault(name, []).append(content)
        self.key_order.setdefault(self.section, []).append(name)

    def new_section(self, section):
        section = section.strip().lower()
        if not section or section == 'general':
            section = None
        self.section = section
        if not section in self.section_order:
            self.section_order.append(section)

class NoDefault:
    pass

def clean_name(name):
    name = name.strip().lower()
    for char in ' \t_-':
        name = name.replace(char, '')
    return name

class Config(object):

    """
    A configuration object.  Acts a little like a dictionary, but not
    really.

    Configuration can be nested with ``[section]`` markers, or can be
    flat (everything globally available).  If in sections then
    ``section.key`` is used, otherwise just ``key``.
    """

    # If False, then no global sections are allowed
    allow_empty_sections = True

    def __init__(self, filename, file=None,
                 allow_empty_sections=NoDefault):
        if allow_empty_sections is not NoDefault:
            self.allow_empty_sections = allow_empty_sections
        self.filename = filename
        p = _ConfigParser(allow_empty_sections=self.allow_empty_sections)
        if file is None:
            p.load(filename)
        else:
            p.loadfile(file)
        self.raw_data = p.data
        self._section_order = p.section_order
        self._key_order = p.key_order
        self.name = os.path.splitext(os.path.basename(filename))[0]

    def keys(self, section=NoDefault):
        if section is NoDefault:
            all = []
            for section_name in self._section_order:
                for key_name in self._key_order[section_name]:
                    if section_name:
                        key_name = '%s|%s' % (section_name, key_name)
                    all.append(key_name)
            return all
        else:
            try:
                return self._key_order[section]
            except KeyError:
                raise KeyError(
                    "Section [%s] not found (from sections %r)"
                    %(section, self._key_order.keys()))

    def sections(self):
        return self.raw_data.keys()

    def getraw(self, key, section=None):
        """
        Mostly for internal use, returns a list of all matching keys.
        """
        if '|' in key:
            assert section is None, (
                "Cannot have | in a key (%r) and an explicit section (%r)"
                % (key, section))
            section, key = key.split('|', 1)
        section = self.clean_section(section)
        try:
            return self.raw_data[section][key]
        except KeyError:
            return ()

    def clean_section(self, section_name):
        if not section_name or section_name == 'general':
            return None
        return section_name.lower()

    def get(self, key, default=None, section=None):
        """
        Get a single value, returning `default` if none found.
        """
        value = self.getraw(key, section=section)
        if not value:
            return default
        else:
            return value[0]

    def getlist(self, key, default=(), section=None):
        """
        Get a list of all matching keys.  Example::

          foo = bar
          foo = baz

        Then::

          >>> config.getlist('foo')
          ['bar', 'baz']
        """
        value = self.getraw(key, section=section)
        if not value:
            return default
        else:
            return value

    true_values = ['t', 'true', '1', 'y', 'yes', 'on']
    false_values = ['f', 'false', '0', 'n', 'no', 'off']

    def getbool(self, key, default=False, section=None):
        """
        Get a single boolean value.  Boolean values are things
        like ``true``, ``false``, etc.
        """
        value = self.getraw(key, section=section)
        if not value:
            return default
        value = value[0]
        if isinstance(value, (str, unicode)):
            value = value.lower()
            if value in self.true_values:
                return True
            elif value in self.false_values:
                return False
            else:
                raise ValueError(
                    "Yes/No value expected for %s (got %r)"
                    % (key, value))
        else:
            return value

    def getint(self, key, default=None, section=None):
        """
        Get an integer value.
        """
        v = self.get(key, default=default, section=section)
        if v is None:
            return v
        else:
            return int(v)
        
    def getinlinelist(self, key, default=(), section=None):
        """
        Get a list, where the list is defined like::

            foo = bar, baz

        Gives::

            >>> config.getinlinelist('foo')
            ['bar', 'baz']
        """
        result = []
        for item in self.getlist(key, default, section):
            item = item.strip()
            if not item:
                continue
            if ',' in item:
                result.extend([i.strip() for i in item.split(',')])
            else:
                result.append(item)
        return result

    def getstartswith(self, startswith, section):
        """
        Returns a list of ``[(key, value), ...]`` for all keys in the
        section that start with startswith.
        """
        result = []
        for key in self.keys(section=section):
            if not key.startswith(startswith):
                continue
            for value in self.getraw(key, section=section):
                result.append((key, value))
        return result

    def __repr__(self):
        return '<%s filename=%s>' % (
            self.__class__.__name__, self.filename)

    def __str__(self):
        data = []
        data.append('%s from %s:' % (
            self.__class__.__name__, self.filename))
        for name, value_list in self.raw_data.get(None, {}).items():
            for value in value_list:
                data.append('%s: %s' % (name, value))
        for section_name, value_dict in self.raw_data.items():
            if section_name is None:
                continue
            data.append('[%s]' % section_name)
            for name, value_list in value_dict.items():
                for value in value_list:
                    data.append('%s: %s' % (name, value))
        return '\n'.join(data)
                
def load_options(parser, options, config, if_exists=True):
    """
    Given a parser object and the parsed options and a configuration
    object or filename, this will load the configuration into the
    parsed options.
    """
    types = {}
    dests = {}
    aliases = {}
    for option in parser.option_list:
        if not option.dest:
            # Some builtin options, like --help
            continue
        name = clean_name(option.dest)
        dests[name] = option.dest
        if option.action in ('store_true', 'store_false'):
            types[name] = 'getbool'
        else:
            types[name] = 'get'
        for lst in option._long_opts, option._short_opts:
            for opt in lst:
                aliases[clean_name(opt)] = name
    if isinstance(config, str):
        if if_exists and not os.path.exists(config):
            return
        config = Config(config)
    for config_key in config.keys():
        name = aliases.get(config_key, config_key)
        if name not in dests:
            raise ValueError(
                "Bad configuration file: option %r unexpected" % config_key)
        value = getattr(config, types[name])(config_key)
        setattr(options, dests[name], value)

        


Node-path: tags/0.1/initools/iniparser.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 7948
Text-content-md5: 3b5b25a5465c039b8a7fb984bcd19497
Text-content-sha1: f146ce49d7bba27b9483db55d0ef5c404cfb1d3a
Content-length: 7958

PROPS-END
"""
A parser for .ini-syntax files.  INIParser should be subclassed to
create a data structure from the file.  See INIParser for more
"""

class ParseError(Exception):

    def __init__(self, message, filename=None, lineno=None, column=None, line=None):
        # Note: right now column is not used, but in some contexts it
        # could be used to print out a line like:
        # error, must be an integer:
        # a = one
        #     ^
        self.message = message
        self.filename = filename
        self.lineno = lineno
        self.column = column
        self.line = line

    def __str__(self):
        msg = self.message
        if self.filename and self.lineno:
            msg += ' in %s:%s' % (self.filename, self.lineno)
        elif self.filename:
            msg += ' in %s' % self.filename
        elif self.lineno:
            msg += ' at line %s' % self.lineno
        return msg

class INIParser:

    """
    A parser for .ini-syntax files.

    Implements all features I know of in .ini files:
    * sections with a [ in the first column
    * assignment via a=b or a: b
    * rfc822-style continuation lines (i.e., start the next line
      with indentation to make it a continuation).
    * ; or # for comments

    This class should be subclassed.  Subclasses may only need to
    implement the .assignment() method.  You may want to use the
    .section attribute, which holds the current section (or None if no
    section has been defined yet).

    Use .parse_error(message) when you encounter a problem; this will
    create an exception that will note the filename and line in which
    the problem occurs.
    """

    def __init__(self):
        self.reset()

    def reset(self):
        pass

    def load(self, filename, encoding='ascii'):
        fileobj = open(filename, 'rb')
        self.loadfile(fileobj, filename=filename, encoding=encoding)
        fileobj.close()

    def loadfile(self, fileobj, filename=None, encoding='ascii'):
        self.start_lineno = 0
        if filename is None:
            filename = getattr(fileobj, 'name', None)
        self.filename = filename
        # lineno is what we are parsing, start_lineno is the last
        # assignment we processed (for multi-line assignments)
        self.start_lineno = 0
        self.lineno = 0
        self.encoding = encoding
        def strip_newline(l):
            if l.endswith('\n'):
                return l[:-1]
            else:
                return l
        self.stream = [strip_newline(l) for l in fileobj.readlines()]
        self.process_file()
        del self.filename
        del self.encoding
        del self.lineno

    def loadstring(self, string, filename=None):
        self.stream = string.splitlines()
        self.filename = filename
        self.start_lineno = 0
        self.lineno = 0
        self.encoding = None
        self.process_file()
        del self.stream
        del self.filename
        del self.lineno
        del self.encoding

    def process_file(self):
        self.section = None
        last_name = None
        accumulated_content = None
        for line in self.stream:
            self.lineno += 1
            # @@: should catch encoding error:
            if self.encoding:
                line = line.decode(self.encoding)
            end_assignment = False
            if not line.strip(): # empty line
                if last_name:
                    self.process_assignment(
                        last_name,
                        accumulated_content)
                    last_name = accumulated_content = None
                    self.start_lineno = self.lineno
                continue
            elif line[0] in (' ', '\t'): # continuation line
                if not last_name:
                    self.error_continuation_without_assignment(line)
                else:
                    accumulated_content.append(line)
                continue
            elif self.get_section(line) is not None: # section line
                if last_name:
                    self.process_assignment(
                        last_name,
                        accumulated_content)
                    last_name = accumulated_content = None
                    self.start_lineno = self.lineno
                self.new_section(self.get_section(line))
            elif self.get_comment(line) is not None: # comment line
                if last_name:
                    self.process_assignment(
                        last_name,
                        accumulated_content)
                    last_name = accumulated_content = None
                    self.start_lineno = self.lineno
                self.add_comment(self.get_comment(line))
            else: # normal assignment
                if last_name:
                    self.process_assignment(
                        last_name,
                        accumulated_content)
                last_name, accumulated_content = self.split_name_value(line)
                self.start_lineno = self.lineno
        if last_name:
            self.process_assignment(
                last_name,
                accumulated_content)

    def split_name_value(self, line):
        colon_pos = line.find(':')
        equal_pos = line.find('=')
        if colon_pos == -1 and equal_pos == -1:
            self.error_missing_equal(line)
            return None
        if (colon_pos == -1
            or (equal_pos != -1 and equal_pos < colon_pos)):
            pos = equal_pos
        else:
            pos = colon_pos
        return line[:pos], [line[pos+1:]]

    def get_comment(self, line):
        """
        Returns None if not a comment
        """
        line = line.lstrip()
        if line.startswith(';') or line.startswith('#'):
            return line[1:]
        return None

    def get_section(self, line):
        """
        Returns None if not a section
        """
        line = line.strip()
        if not line.startswith('['):
            return None
        if not line.endswith(']'):
            self.error_section_without_end_bracket(line)
            return None
        return line[1:-1]
                        
    def process_assignment(self, name, accumulated_content):
        content = '\n'.join([l.lstrip() for l in accumulated_content])
        self.assignment(name.strip(), content)

    def assignment(self, name, content):
        raise NotImplementedError

    def new_section(self, section):
        if not section:
            self.error_no_section_name()
        self.section = section

    def add_comment(self, comment):
        pass

    def error_continuation_without_assignment(self, line):
        self.parse_error('Invalid indentation', line)

    def error_section_without_end_bracket(self, line):
        self.parse_error('Invalid section (must end with ])', line)

    def error_missing_equal(self, line):
        self.parse_error(
            'Lines should look like "name=value" or "name: value"',
            line)

    def error_no_section_name(self):
        self.parse_error(
            'Empty section name ([])')

    def parse_error(self, msg, line=None):
        raise ParseError(
            msg,
            filename=self.filename,
            lineno=self.lineno,
            line=line)

class BasicParser(INIParser):

    """
    A simple subclass of INIParser; creates a nested data structure
    like ``{'section_name': {'variable': ['values']}}``

    Usage::

        >>> p = BasicParser()
        >>> p.load('config.ini')
        >>> data = p.data
    """

    def reset(self):
        self.data = {}
        INIParser.reset(self)

    def assignment(self, name, content):
        if not self.section:
            self.parse_error(
                'Assignments can only occur inside sections; no section has been defined yet')
        section = self.data.setdefault(self.section, {})
        section.setdefault(name, []).append(content)
        
    


Node-path: tags/0.1/initools/inischema.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 13365
Text-content-md5: 32d0155f8b2bb2b6b43574722c12e52c
Text-content-sha1: 142e017dd0a73d1db4ac2ce616071f39693ab133
Content-length: 13375

PROPS-END
"""
.ini file schemas

You can define a schema for your .ini configuration files, which
defines the types and defaults for the values.  You can also define
a catchall attribute.

TODO
----

Currently, this does not deal with sections at all, and sections are
not allowed.  That wil take some more thought, as the schemas will
probably be per-section (though one section may inherit from another,
or defaults may be inherited, etc, which should be allowed for).

Documentation isn't kept track of, nor is it generated.  It should
possible to indicate with ``opt(help=...)``, and as an option
to ``INISchema.ini_repr()`` you should be able to put in documentation
in comments.

Comments aren't kept track of.

Key order isn't kept track of.

Minimal .ini files should be possible to generate -- only generating
keys when the default doesn't match the actual value.

There should be a way to check that the entire config is loaded, and
there are no missing values (options which weren't set and have no
default).

Usage
-----

::

    class VHostSchema(INISchema):

        server_name = opt()
        port = optint(default=80)
        # optlist means this can show up multiple times:
        server_alias = optlist(default=[])
        document_root = opt()

    vhost = VHostSchema()
    vhost.load('config.ini')
    connect(vhost.server_name, vhost.port)
    # etc.

Any schema can contain an ``optdefault()`` object, which will
pick up any keys that aren't specified otherwise (if not present,
extra keys are an error).  Then you'll get a dictionary of lists,
for all the extra config values.  (Use
``optdefault(allow_multiple=False)`` if you want a dictionary of
strings).

If you expect multiple values, use ``optlist(subtype=optsomething())``
for a key.  The values will be collected in a list; if you don't
indicate ``subtype`` then ``opt()`` is used.  Other types are
fairly easy to make through subclassing.

You can generate config files by using ``schema.ini_repr()`` which
will return a string version of the ini file.

Implementation
--------------

This makes heavy use of descriptors.  If you are not familiar with
descriptors, see http://users.rcn.com/python/download/Descriptor.htm

It also makes light use of metaclasses.
"""


import iniparser

class INIMeta(type):

    def __new__(meta, class_name, bases, d):
        cls = type.__new__(meta, class_name, bases, d)
        cls.__classinit__.im_func(cls, d)
        return cls

class ParseValueError(Exception):
    pass

class NoDefault:
    pass

class INISchema(object):

    __metaclass__ = INIMeta

    _default_option = None
    _default_values = None

    _config_names = {}
    _config_names_lower = {}

    case_insensitive = False

    def __classinit__(cls, d):
        # We don't initialize INISchema itself:
        if cls.__bases__ == (object,):
            return
        cls._config_names = cls._config_names.copy()
        cls._config_names_lower = cls._config_names_lower.copy()
        for name, value in d.items():
            if isinstance(value, opt):
                cls.add_option(name, value)
        # @@: We should look for None-ified options, and remove
        # them from cls._config_names

    def add_option(cls, attr_name, option):
        """
        Classmethod: add the option using the given attribute name.
        This can be called after the class has been created, to
        dynamically build up the options.
        """
        if isinstance(option, optdefault):
            # We use a list so that the descriptor behavior doesn't
            # apply here:
            cls._default_option = [option]
            option.attr_name = attr_name
            return
        if option.names is None:
            option.names = [attr_name]
        option.attr_name = attr_name
        for option_name in option.names:
            cls._config_names[option_name] = option
            cls._config_names_lower[option_name.lower()] = option
        option.set_schema(cls)
        setattr(cls, attr_name, option)

    add_option = classmethod(add_option)

    def __init__(self):
        self._ini_attrs = {}

    def set_config_value(self, name, value):
        if self.case_insensitive:
            name = name.lower()
            config_names = self._config_names_lower
        else:
            config_names = self._config_names
        if config_names.has_key(name):
            setattr(self, config_names[name].attr_name, value)
        elif not self._default_option:
            raise ParseValueError(
                "The setting %r was not expected (from %s)"
                % (name, ', '.join(config_names.keys()) or 'none'))
        else:
            self._default_option[0].set_config_value(
                self, name, value)

    def _parser(self):
        return SchemaINIParser(self)

    def load(self, filename, **kw):
        """
        Loads the filename.  Use the encoding keyword argument to
        specify the file's encoding.
        """
        self._parser().load(filename, **kw)

    def loadstring(self, string, **kw):
        """
        Loads the string, which is the content of the ini files.
        Use the filename keyword argument to indicate the filename
        source (or another way to identify the source of the string
        in error messages).
        """
        self._parser().loadstring(string, **kw)

    def as_dict(self, fold_defaults=False):
        """
        Returns the loaded configuration as a dictionary.
        """
        # @@: default values won't show up here
        v = self._ini_attrs.copy()
        if fold_defaults:
            if self._default_values:
                v.update(self._default_values)
        elif self._default_option:
            v[self._default_option[0].attr_name] = self._default_values or {}
        return v

    def ini_repr(self):
        """
        Returns the loaded values as a string, suitable as a
        configuration file.
        """
        config_names = []
        used_options = {}
        for option in self._config_names.values():
            if used_options.has_key(option):
                continue
            used_options[option] = None
            config_names.append((option.names[0], option))
        config_names.sort()
        if self._default_option:
            config_names.append((None, self._default_option[0]))
        result = []
        for name, option in config_names:
            result.append(option.ini_assignment(
                self, getattr(self, option.attr_name)))
        return ''.join(result)
    
class opt(object):

    default = NoDefault

    def __init__(self, names=None, **kw):
        self.names = names
        self.attr_name = None
        self.schema = None
        for name, value in kw.items():
            if not hasattr(self, name):
                raise TypeError(
                    "The keyword argument %s is unknown"
                    % name)
            setattr(self, name, value)

    def set_schema(self, schema):
        self.schema = schema

    def __get__(self, obj, type=None):
        if obj is None:
            return self
        try:
            return obj._ini_attrs[self.attr_name]
        except KeyError:
            if self.default is not NoDefault:
                return self.default
            raise AttributeError(
                "The attribute %s has not been set on %r"
                % (self.attr_name, obj))

    def __set__(self, obj, value):
        new_value = self.convert(obj, value)
        self.validate(obj, new_value)
        self.set_value(obj, new_value)

    def convert(self, obj, value):
        return value

    def validate(self, obj, value):
        pass

    def set_value(self, obj, value):
        obj._ini_attrs[self.attr_name] = value

    def __delete__(self, obj):
        try:
            del obj._ini_attrs[self.attr_name]
        except KeyError:
            raise AttributeError(
                "%r does not have an attribute %s"
                % (obj, self.attr_name))

    def ini_assignment(self, obj, value, name=None):
        if name is None:
            name = self.names[0]
        return '%s=%s\n' % (name,
                            self.ini_fold(self.ini_repr(obj, value)))

    def ini_fold(self, value):
        lines = value.splitlines()
        if len(lines) <= 1:
            return value
        lines = [lines[0]] + ['    ' + l for l in lines[1:]]
        return '\n'.join(lines)

    def ini_repr(self, obj, value):
        return str(value)
    
optstring = opt

class optint(opt):

    max = None
    min = None

    bad_type_message = "You must give an integer number, not %(value)r"
    too_large_message = "The value %(value)s is too large"
    too_small_message = "The value %(value)s is too small"
    coerce = int
    
    def convert(self, obj, value):
        try:
            new_value = self.coerce(value)
        except ValueError:
            raise ParseValueError(
                self.bad_type_message % {'value': value})
        if self.max is not None and new_value > self.max:
            raise ParseValueError(
                self.too_large_message % {'value': value})
        if self.min is not None and new_value < self.min:
            raise ParseValueError(
                self.too_small_message % {'value': value})
        return new_value

class optfloat(optint):
    
    coerce = float
    bad_type_message = "You must give a float number, not %(value)r"

class optbool(opt):

    true_values = ('yes', 'true', '1', 'on')
    false_values = ('no', 'false', '0', 'off')

    def convert(self, obj, value):
        if value.lower() in self.true_values:
            return True
        elif value.lower() in self.false_values:
            return False
        else:
            raise ParseValueError(
                "Should be a boolean value (true/false, on/off, yes/no), not %r"
                % value)

    def ini_repr(self, obj, value):
        if value:
            return 'true'
        else:
            return 'false'

class optlist(opt):

    subtype = opt

    def __init__(self, *args, **kw):
        opt.__init__(self, *args, **kw)
        if isinstance(self.subtype, type):
            self.subtype = self.subtype()

    def convert(self, obj, value):
        return self.subtype.convert(obj, value)

    def validate(self, obj, value):
        self.subtype.validate(obj, value)

    def set_value(self, obj, value):
        obj._ini_attrs.setdefault(self.attr_name, []).append(value)

    def ini_assignment(self, obj, value, name=None):
        if name is None:
            name = self.names[0]
        assert not isinstance(value, (str, unicode)), (
            "optlist attributes should receive lists or sequences, not "
            "strings (%r)" % value)
        all = [self.subtype.ini_assignment(obj, sub, name=name)
               for sub in value]
        return ''.join(all)

class optdefault(opt):

    allow_multiple = True

    def set_config_value(self, obj, name, value):
        if obj._default_values is None:
            obj._default_values = {}
        if self.allow_multiple:
            obj._default_values.setdefault(name, []).append(value)
        else:
            if obj._default_values.has_key(name):
                raise ParseValueError(
                    "You have already set the configuration key %r"
                    % name)
            obj._default_values[name] = value

    def __get__(self, obj, type=None):
        if obj is None:
            return self
        return obj._default_values or {}

    def __set__(self, obj, value):
        raise AttributeError(
            "The attribute %s cannot be set" % self.attr_name)

    def ini_assignment(self, obj, value, name=None):
        assert name is None, "default values can't accept a name"
        all = []
        all_values = self.__get__(obj).items()
        all_values.sort()
        for name, value in all_values:
            if isinstance(value, (str, unicode)):
                value = [value]
            for subvalue in value:
                all.append('%s=%s\n' % (
                    name, self.ini_fold(self.ini_repr(obj, subvalue))))
        return ''.join(all)

class optconverter(opt):

    misc_error_message = "%(error_type)s: %(message)s"
    converter_func = None

    def convert(self, obj, value):
        try:
            return self.converter_func(value)
        except Exception, e:
            raise ParseValueError(
                self.misc_error_message % {
                'message': str(e),
                'error_type': e.__class__.__name__})

    _converters = {}
    def get_converter(cls, name, converter_func):
        if cls._converters.has_key(id(converter_func)):
            return cls._converters[(name, id(converter_func))]
        else:
            converter = cls(name, converter_func=converter_func)
            cls._converters[(name, id(converter_func))] = converter
            return converter
    get_converter = classmethod(get_converter)

class SchemaINIParser(iniparser.INIParser):

    def __init__(self, schema):
        self.schema = schema

    def new_section(self, section):
        self.parse_error("Schemas do not yet support sections")

    def assignment(self, name, content):
        try:
            self.schema.set_config_value(name, content)
        except ParseValueError, e:
            self.parse_error(e.args[0])


Node-path: tags/0.1/initools/lazyiniparser.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 5274
Text-content-md5: dc61dc2d1d15c2790311d6bd393efb5d
Text-content-sha1: ecb27606d4374ce8d4863f1f33fd37a0e57a0214
Content-length: 5284

PROPS-END
"""
A parser that keeps lots of information around, so the file can be
reconstructed almost exactly like it originally was entered.  Also, if
there are errors with values, they can be tracked back to a file and
line number.
"""

from iniparser import INIParser, ParseError

class ConversionError(Exception):
    pass

def canonical_name(name):
    return name.lower().replace(' ', '').replace('_', '')

class LazyINIParser(INIParser):

    def __init__(self, allow_empty_sections=False):
        self.allow_empty_sections = allow_empty_sections
        INIParser.__init__(self)

    def reset(self):
        self.configuration = Configuration()
        self.last_comment = []

    def add_comment(self, line):
        if line.startswith(' '):
            line = line[1:]
        self.last_comment.append(line)

    def assignment(self, name, content):
        item = Item(section=self.section,
                    name=name,
                    content=content,
                    comment='\n'.join(self.last_comment),
                    filename=self.filename,
                    lineno=self.start_lineno)
        self.last_comment = []
        if not self.section:
            self.new_section('')
        self.section.add_item(item)

    def new_section(self, section):
        if not section and not self.allow_empty_sections:
            self.error_no_section_name()
        self.section = Section(
            name=section.strip(),
            comment='\n'.join(self.last_comment))
        self.configuration.add_section(self.section)
        self.last_comment = []

class Configuration(object):

    def __init__(self):
        self.sections = []
        self.sections_by_name = {}

    def add_section(self, section):
        self.sections.append(section)
        # @@: I shouldn't be doing this here, I'll do it in lazyloader
        #names = self.split_names(section.name)
        #d = self.sections_by_name
        #for name in names[:-1]:
        #    d = d.setdefault(name, {})
        #d.setdefault(names[-1], []).append(section)

    def split_names(self, name):
        names = []
        while 1:
            dot_pos = name.find('.')
            paren_pos = name.find('(')
            if dot_pos == -1 and paren_pos == -1:
                next = canonical_name(name)
                if next:
                    names.append(next)
                return names
            if (dot_pos == -1 or (dot_pos > paren_pos
                                  and paren_pos != -1)):
                next = canonical_name(name[:paren_pos])
                if next:
                    names.append(next)
                name = name[paren_pos+1:]
                next_pos = name.find(')')
                assert next_pos != -1, (
                    "Bad section name, ) expected: %r" % name)
                names.append(name[:next_pos])
                name = name[next_pos+1:]
            else:
                assert dot_pos != -1
                assert paren_pos == -1 or dot_pos < paren_pos
                next = canonical_name(name[:dot_pos])
                assert next, (
                    "Empty name")
                names.append(next)
                name = name[dot_pos+1:]

    def source(self):
        return '\n\n'.join([s.source() for s in self.sections])

class Section(object):

    def __init__(self, name, comment):
        self.name = name
        self.comment = comment
        self.items = []
        self.canonical = {}

    def add_item(self, item):
        self.items.append(item)
        self.canonical.setdefault(
            canonical_name(item.name), []).append(item)

    def __repr__(self):
        return '<%s name=%r>' % (self.__class__.__name__, self.name)

    def source(self):
        s = ''
        if self.comment:
            s += '\n'.join(['# ' + l
                            for l in self.comment.splitlines()]) + '\n'
        s += '[%s]\n' % self.name
        s += ''.join([i.source() for i in self.items])
        return s


class Item(object):

    def __init__(self, section, name, content, comment,
                 filename, lineno):
        self.section = section
        self.name = name
        self.content = content
        self.comment = comment
        self.filename = filename
        self.lineno = lineno

    def value(self, name, converter=None, catch_all_exceptions=False):
        if catch_all_exceptions:
            ExcClass = Exception
        else:
            ExcClass = ConversionError
        if converter is not None:
            try:
                return converter(self.content)
            except ExcClass, e:
                msg = str(e)
                raise ParseError(
                    msg,
                    filename=self.filename,
                    lineno=self.lineno,
                    column=None)
        else:
            return self.content

    def __str__(self):
        return self.content

    def __repr__(self):
        return '<%s name=%r; value=%r>' % (
            self.__class__.__name__, self.name, self.content)

    def source(self):
        s = ''
        if self.comment:
            s += '\n'.join(['# ' + l
                            for l in self.comment.splitlines()]) + '\n'
        s += '%s = %s\n' % (self.name, self.content)
        return s


Node-path: tags/0.1/initools/lazyloader.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 8381
Text-content-md5: 2af60003425966427d87bc29e64a168d
Text-content-sha1: 99a38171ccde4128be90fe39189e262699f1c235
Content-length: 8391

PROPS-END
"""
A config file loader that can load and nest multiple config files, the
config files can have structure, and the values can be tracked back to
their original file and line number.

To start, you'd do something like:

    >>> config = LazyLoader()

You could use ``.load(filename)`` to load a config file; for the
examples it is convenient to instead use loadstring, and give a fake
filename:

    >>> config_data = \"\"\"
    ... [server]
    ... port = 8000
    ... host = localhost
    ... document_root = /var/www
    ... \"\"\"
    >>> config.loadstring(config_data, filename='config_data.conf')
    >>> config['server']['port']
    '8000'
    >>> config['server'].convert('port', int)
    8000
    >>> config['server'].convert('host', int)
    Traceback (most recent call last):
        ...
    ValueError: Error in config_data.conf (section [server]), line 4 ('localhost'):
    ValueError: invalid literal for int(): localhost

Note that names are normalized, removing case, underscores, and
spaces.  So to get to the document root:

    >>> config['server']['documentroot']
    '/var/www'

You can also merge in values; for instance, consider a virtual host
that overrides global values:

    >>> vhost_data = \"\"\"
    ... [vhost(my.host.com)]
    ... document_root = /path/to/root
    ... \"\"\"
    >>> vhost_config = LazyLoader()
    >>> vhost_config.loadstring(vhost_data, filename='vhost_data.conf')
    >>> vhost_config['vhost'].keys()
    ['my.host.com']

Note that key and section names can be nested with .'s, and ()'s quote
the values (so the key is ['my.host.com'] instead of
['my']['host']['com']).  Then we may want to merge this in, based on a
condition (e.g., the hostname matches my.host.com):

    >>> config['server'].merge(vhost_config['vhost']['my.host.com'])
    >>> config['server']['documentroot']
    '/path/to/root'

"""

from lazyiniparser import LazyINIParser, Item
from nested import NestedDict
import inischema
import re
from UserDict import UserDict, DictMixin

class LazyLoader(NestedDict):

    def __init__(self, configs=None, mutable=False, nest=True,
                 section_name=None, master=None):
        self.section_name = section_name
        self.master = master
        NestedDict.__init__(self, configs=configs, mutable=mutable,
                            nest=nest)
        
    def load(self, filename):
        parser = LazyINIParser(allow_empty_sections=True)
        parser.load(filename)
        config = self._convert_configuration(parser.configuration)
        self.add_config(config)

    def loadstring(self, s, filename=None):
        parser = LazyINIParser(allow_empty_sections=True)
        parser.loadstring(s, filename=filename)
        config = self._convert_configuration(parser.configuration)
        self.add_config(config)

    def merge(self, lazyloader):
        if self.master:
            self.master._propagate_merge([self.section_name], lazyloader)
        else:
            self._propagate_merge([], lazyloader)

    def _propagate_merge(self, slave_keys, lazyloader):
        if self.master:
            slave_keys.insert(0, self.section_name)
            self.master._propagate_merge(slave_keys, lazyloader)
        else:
            configs = filter(None, lazyloader.configs)
            new_configs = []
            for config in configs:
                if slave_keys:
                    new_config = {}
                    set_config = new_config
                    for key in slave_keys[:-1]:
                        set_config[key] = {}
                        set_config = set_config[key]
                    set_config[slave_keys[-1]] = config
                else:
                    new_config = config
                self.add_config(new_config)

    def __getitem__(self, key):
        try:
            return NestedDict.__getitem__(self, key)
        except KeyError, e:
            if self.section_name is None:
                section = 'global section'
            else:
                section = 'section [%s]' % self.section_name
            raise KeyError(
                "Key %r not found in %s" % (key, section))

    def _convert_configuration(self, conf):
        data = {}
        for section in conf.sections:
            section_keys = self._parse_keys(section.name)
            if section_keys == ['global']:
                section_keys = []
            for item in section.items:
                item_keys = self._parse_keys(item.name)
                all_keys = section_keys + item_keys
                pos = data
                for key in all_keys[:-1]:
                    pos = pos.setdefault(key, {})
                pos.setdefault(all_keys[-1], []).append(item)
        return data

    def _parse_keys(self, name):
        keys = []
        orig_name = name
        name = name.strip()
        while 1:
            next_period = name.find('.')
            next_paren = name.find('(')
            if next_paren == -1 and next_period == -1:
                next = self._canonical_name(name)
                if next:
                    keys.append(next)
                return keys
            elif (next_paren == -1
                or next_period != -1 and next_period < next_paren):
                next = self._canonical_name(name[:next_period])
                if next:
                    keys.append(next)
                name = name[next_period+1:]
            else:
                assert next_paren != -1
                assert next_period == -1 or next_paren < next_period
                next = self._canonical_name(name[:next_paren])
                if next:
                    keys.append(next)
                name = name[next_paren+1:]
                next_close = name.find(')')
                if next_close == -1:
                    raise inischema.ParseValueError(
                        "Key name contains a ( with no closing ): %r"
                        % orig_name)
                next = name[:next_close]
                keys.append(next)
                name = name[next_close+1:]

    _canonical_re = re.compile('[_ \t-]')
    def _canonical_name(self, name):
        return self._canonical_re.sub('', name.lower())

    def _convert_single(self, key, value_list):
        if isinstance(value_list[0], (dict, DictMixin, UserDict)):
            return self.__class__(
                value_list, mutable=self.mutable, nest=True,
                section_name=key, master=self)
        elif isinstance(value_list[0][-1], Item):
            return value_list[0][-1].content
        else:
            return value_list[0][-1]

    def getlist(self, key, add_inherited=True):
        results = self.raw_get(key, add_inherited=add_inherited)
        converted = []
        for result_set in results:
            if not isinstance(result_set, (list, tuple)):
                result_set = [result_set]
            for item in result_set:
                if isinstance(item, (dict, UserDict, DictMixin)):
                    value = self.__class__(
                        [item], mutable=self.mutable, nest=self.nest)
                elif isinstance(item, Item):
                    value = item.content
                else:
                    value = item
                converted.append(value)
        return converted

    def _make_converter(self, key, converter):
        if not isinstance(converter, inischema.opt):
            converter = inischema.optconverter.get_converter(
                key, converter_func=converter)
        return converter

    def convert(self, key, converter):
        converter = self._make_converter(key, converter)
        try:
            return converter.convert(None, self[key])
        except inischema.ParseValueError, e:
            item = self.raw_get(key)[0][0]
            message = ('Error in %s (section [%s]), line %i (%r):\n%s'
                       % (item.filename, item.section.name, item.lineno,
                          self[key], e))
            raise ValueError(message)

    def convertlist(self, key, converter, add_inherited=True):
        converter = self._make_converter(key, converter)
        value_list = self.getlist(key, add_inherited=add_inherited)
        new_list = []
        try:
            for value in value_list:
                new_list.append(converter.convert(value))
        except inischema.ParseValueError, e:
            pass
        
        


Node-path: tags/0.1/initools/nested.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 5262
Text-content-md5: 504522d3fa0d2405c84faa9ed800b84d
Text-content-sha1: f3e933b3867efae1ddf0129a60143a30a6019411
Content-length: 5272

PROPS-END
"""
Layers multiple dictionaries.

Nested dictionaries can be traversed, with each dictionary shadowing
the previous dictionaries.  So for example:

    >>> d = NestedDict([{'foo': 'bar'}])
    >>> d['foo']
    'bar'
    >>> d2 = d.clone(add_dict={'foo': 'bar2'})
    >>> d2['foo']
    'bar2'
    >>> d2.getlist('foo')
    ['bar2', 'bar']

This works for deeply nested dictionaries, not just at the top level;
each nested dictionary gets wrapped in a NestedDict as well.
"""

from UserDict import DictMixin, UserDict

class NestedDict(DictMixin):

    def __init__(self, configs=None, mutable=True, nest=True):
        if configs is None:
            configs = [{}]
        assert isinstance(configs, (list, tuple)), (
            "The configs must be a list or tuple, not: %r"
            % configs)
        self.configs = configs
        self.mutable = mutable
        self.nest = nest

    def __getitem__(self, key):
        results = self.raw_get(key)
        if not results:
            raise KeyError, "Key not found: %r" % key
        return self._convert_single(key, results)

    def add_config(self, config, position=0):
        assert not isinstance(config, (str, unicode)), (
            "Bad configuration (not a mapping): %r" % config)
        if position is None:
            self.configs.append(config)
        else:
            self.configs.insert(position, config)

    def set_configs(self, new_configs):
        self.configs[:] = []
        for config in new_configs:
            self.add_config(config, None)

    def raw_get(self, key, add_inherited=True):
        results = []
        if add_inherited:
            all_configs = self.configs
        else:
            all_configs = [self.configs[-1]]
        for config in all_configs:
            if key in config:
                if isinstance(config, (str, unicode)):
                    print [key, config, all_configs, self.configs]
                results.append(config[key])
        return results

    def getlist(self, key, add_inherited=True):
        results = self.raw_get(key, add_inherited=add_inherited)
        converted = []
        for result_set in results:
            if not isinstance(result_set, (list, tuple)):
                result_set = [result_set]
            converted.extend(self._convert_many(key, result_set))
        return converted

    def _convert_single(self, key, value_list):
        if (not self.nest
            or not isinstance(value_list[0],
                              (dict, DictMixin, UserDict))):
            # @@: doesn't handle all dict alternatives
            return value_list[0]
        elif len(value_list) == 1 and self.mutable:
            return value_list[0]
        else:
            return self.__class__(
                value_list, mutable=self.mutable, nest=True)

    def _convert_many(self, key, value_list):
        return [self._convert_single(key, [v]) for v in value_list]

    def __setitem__(self, key, value):
        if self.mutable:
            self.configs[0][key] = value
        else:
            raise KeyError, (
                "Dictionary is read-only")

    def __delitem__(self, key):
        if not self.mutable:
            raise KeyError, (
                "Dictionary is read-only")
        if self.configs[0].has_key(key):
            del self.configs[0][key]
        elif self.has_key(key):
            raise KeyError, (
                "You cannot delete the key %r, as it belongs to the "
                "a master configuration %r"
                % (key, self.master))
        else:
            raise KeyError, (
                "Key does not exist: %r" % key)

    def keys(self):
        return list(self)

    def __contains__(self, key):
        for config in self.configs:
            if config.has_key(key):
                return True
        return False

    def has_key(self, key):
        return key in self

    def __iter__(self):
        used = {}
        for config in self.configs:
            for key in config:
                if key in used:
                    continue
                used[key] = None
                yield key

    _clone_sentry = []

    def clone(self, add_dict=None, mutable=_clone_sentry,
              nest=_clone_sentry):
        if mutable is self._clone_sentry:
            mutable = self.mutable
        if nest is self._clone_sentry:
            nest = self.nest
        new = self.configs[:]
        if add_dict is not None:
            new.insert(0, add_dict)
        else:
            new.insert(0, {})
        return self.__class__(new, mutable=mutable, nest=nest)

    def copy(self):
        return dict(self.iteritems())

    def __eq__(self, other):
        if other is None:
            return False
        if (not hasattr(other, 'keys')
            or not hasattr(other, '__getitem__')):
            return False
        for key in other:
            if not key in self:
                return False
        for name, value in self.iteritems():
            if other[name] != value:
                return False
        return True

    def __cmp__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return '<%s %r>' % (self.__class__.__name__,
                            dict(self.iteritems()))


Node-path: tags/0.1/setup.cfg
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 200
Text-content-md5: 52201f0f7a47cb4a0305ad47440767eb
Text-content-sha1: 44276fc91b55dce051158fce09a07d209ee1aadb
Content-length: 210

PROPS-END
[pudge]
dest = docs/html
title = INI Tools
modules = initools
docs = docs/index.txt

[publish]
doc-dest = scp://ianb@webwareforpython.org/home/paste/htdocs/initools
make-dirs = 1
doc-dir = docs/html



Node-path: tags/0.1/setup.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 751
Text-content-md5: df9645e2d82ac2065ace2f501d920e5c
Text-content-sha1: f34645d2a1a87ac7aef7f356df141a7fc2d811a6
Content-length: 761

PROPS-END
from setuptools import setup, find_packages

version = '0.1'

setup(name='INITools',
      version=version,
      description="",
      long_description="""\
A set of tools for parsing and using ``.ini``-style files, including
an abstract parser and several tools built on that parser.
""",
      classifiers=[
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Topic :: Software Development :: Libraries",
        ],
      url="http://pythonpaste.org/initools/",
      keywords="config parser ini",
      author="Ian Bicking",
      author_email="ianb@colorstudy.com",
      license="MIT",
      packages=find_packages(exclude=['ez_setup', 'examples', 'tests']),
      zip_safe=True,
      )
      


Node-path: tags/0.1/tests
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Node-path: tags/0.1/tests/test_iniparser.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 1471
Text-content-md5: ff792646dc3d512a59a72700b2b07be5
Text-content-sha1: 5f8f6c0bb89ec543efed9357f34b3b21146a5f5d
Content-length: 1481

PROPS-END
from initools import iniparser
import re

def parse(s, filename='test.ini'):
    p = iniparser.BasicParser()
    p.loadstring(s, filename=filename)
    return p

def raises(sample, match):
    if isinstance(match, str):
        match = re.compile(match)
    try:
        parse(sample)
    except iniparser.ParseError, e:
        if match and not match.search(str(e)):
            raise
    else:
        assert 0, "Parsing %r should have raised an error" % sample

def test_no_section():
    raises(
        """# A file...
a=10
""", r'^Assignments can only.*')
        
def test_no_equal():
    raises(
        """[a file]
this is a test
""", r'^Lines should look like.*')

def test_bad_section():
    raises(
        """[file
""", r'^Invalid section.*')

def test_empty_section():
    raises(
        """[]
""", r'^Empty section name.*')

def test_equal_colon():
    sec = parse("""[test]
a=1:2
b: 1=3""").data['test']
    assert sec['a'] == ['1:2']
    assert sec['b'] == ['1=3']

def test_multi_section():
    data = parse("""[test]
#a=1
a=2
a=3
a=4
[test2]
a=1
""").data
    assert data['test']['a'] == ['2', '3', '4']
    assert data['test2']['a'] == ['1']

def test_continuation():
    data = parse("""[test]
a = a
   pretty
 bird
\tb=3
b=another
  line
[test2]
[test3]
c=[blah]
  [blah]""").data
    assert data['test']['a'] == ['a\npretty\nbird\nb=3']
    assert data['test']['b'] == ['another\nline']
    assert data['test3']['c'] == ['[blah]\n[blah]']
        


Node-path: tags/0.1/tests/test_inischema.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 2229
Text-content-md5: 9dc4501ed3a64c584bb3f347035c2a89
Text-content-sha1: fd07ef2a4c9d047c2c40139040dd56ccff9ef814
Content-length: 2239

PROPS-END
from initools.inischema import *

class Schema1(INISchema):
    
    number = optint()
    maybe = optbool(names=['maybe', 'or not'])
    float = optfloat()
    string = opt()
    string2 = opt()
    rep = optlist(subtype=optint())
    whatever = opt(default=5)

class Schema2(INISchema):

    a = optint()
    default = optdefault()

class Schema3(Schema2):
    pass
Schema3.add_option('default', optdefault(allow_multiple=False))
Schema3.add_option('b', optlist(subtype=optint()))

def parse_schema(schema, string, filename='test.ini'):
    if not isinstance(schema, INISchema):
        schema = schema()
    schema.loadstring(string)
    return schema

load_ini = """
number = 1
float = 1
or not = true
string = something
string2=something
rep=1
rep=5
rep=10
"""

def test_load():
    s = parse_schema(Schema1, load_ini)
    assert s.as_dict() == {
        'number': 1,
        'maybe': True,
        'float': 1.0,
        'string': 'something',
        'string2': 'something',
        'rep': [1, 5, 10]}
    assert s.number == 1
    assert s.rep == [1, 5, 10]
    assert s.whatever == 5
    assert s.string == 'something'

def test_unload():
    s = parse_schema(Schema1, load_ini)
    assert s.ini_repr() == """\
float=1.0
maybe=true
number=1
rep=1
rep=5
rep=10
string=something
string2=something
whatever=5
"""
                         

default_ini = """
a = 1
b = 2
c = 3
"""

def test_default():
    s = parse_schema(Schema2, default_ini)
    assert s.as_dict() == {
        'a': 1,
        'default': {'b': ['2'],
                    'c': ['3']}}
    assert s.as_dict(fold_defaults=True) == {
        'a': 1,
        'b': ['2'],
        'c': ['3']}

def test_default2():
    s = parse_schema(Schema3, default_ini)
    assert s.as_dict() == {
        'a': 1,
        'b': [2],
        'default': {'c': '3'}}
    assert s.as_dict(fold_defaults=True) == {
        'a': 1, 'b': [2], 'c': '3'}

def test_gen():
    s = parse_schema(Schema2, default_ini)
    assert s.ini_repr() == "a=1\nb=2\nc=3\n"
    s.a = 2
    assert s.ini_repr() == "a=2\nb=2\nc=3\n"

def test_gen2():
    s = parse_schema(Schema3, default_ini)
    assert s.ini_repr() == "a=1\nb=2\nc=3\n"
    s.a = 2
    assert s.ini_repr() == "a=2\nb=2\nc=3\n"
    


Node-path: tags/0.1/tests/test_lazyiniparser.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 593
Text-content-md5: 0b8e2df0e786d76bd3cd2a9411ac6e3d
Text-content-sha1: 4a5c2cc71ac6d1210ecb4889c526fc1877eb1607
Content-length: 603

PROPS-END
from initools import lazyiniparser

def parse(s, filename='test.ini'):
    p = lazyiniparser.LazyINIParser()
    p.loadstring(s, filename=filename)
    return p.configuration


data = """\
# a test
[section 1]
a = 2
a2 = 3
# one more...
a = 4
"""

def test_simple():
    c = parse(data)
    assert len(c.sections) == 1
    assert c.sections[0].name == 'section 1'
    assert c.sections[0].comment == 'a test'
    items = c.sections[0].items
    assert [i.name for i in items] == ['a', 'a2', 'a']
    assert [i.lineno for i in items] == [3, 4, 6]
    assert c.source() == data
        
       


Node-path: tags/0.1/tests/test_lazyloader.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 3151
Text-content-md5: 49848d35fe755364f53d9cf287901ba7
Text-content-sha1: 84af48a724ede3ef6f50322934ac3bee6e7c0825
Content-length: 3161

PROPS-END
from initools import lazyloader
import py.test

# @@: Should also test docstrings

data1 = """\
[ages]

jeanette = 72
dave = 54

[children]

jeanette = dave
dave = ian
dave = monica
"""

try:
    sorted
except NameError:
    def sorted(v):
        v = list(v)
        v.sort()
        return v

def test_create():
    config = lazyloader.LazyLoader()
    config.loadstring(data1, filename="data1.conf")
    assert sorted(config.keys()) == ['ages', 'children']
    assert config['ages']['jeanette'] == '72'
    assert config['ages']['dave'] == '54'
    assert config['children']['dave'] == 'monica'
    assert config['children']['jeanette'] == 'dave'
    assert config['children'].getlist('dave') == ['ian', 'monica']
    assert config['ages'].convert('jeanette', int) == 72
    py.test.raises(
        ValueError,
        config['children'].convert, 'jeanette', int)
    py.test.raises(
        KeyError,
        config['children'].convert, 'joe', str)
    py.test.raises(
        KeyError,
        config.__getitem__, 'child')
    
data2 = """\
[children]
# Another child...
jeanette = mary
"""

def test_fold():
    config = lazyloader.LazyLoader()
    config.loadstring(data1, filename="data1.conf")
    config.loadstring(data2, filename="data2.conf")
    assert config['children']['jeanette'] == 'mary'
    assert (sorted(config['children'].getlist('jeanette'))
            == ['dave', 'mary'])
    assert config['children']['dave'] == 'monica'
    assert sorted(config.keys()) == ['ages', 'children']
    assert sorted(config['children'].keys()) == ['dave', 'jeanette']

data3 = """\
children.mary = vada
[global]
children.mary = armen
"""

data4 = """\
george = chelsea
"""

data5 = """\
[something(here!)]
test.this.out = foo
"""

def test_global():
    config = lazyloader.LazyLoader()
    config.loadstring(data1, filename="data1.conf")
    config.loadstring(data2, filename="data2.conf")
    config.loadstring(data3, filename="data3.conf")
    assert config['children']['mary'] == 'armen'
    assert config['children'].getlist('mary') == ['vada', 'armen']
    merged = lazyloader.LazyLoader()
    merged.loadstring(data4, filename="data4.conf")
    config['children'].merge(merged)
    assert config['children']['george'] == 'chelsea'
    config.merge(merged)
    assert config['george'] == 'chelsea'
    merge2 = lazyloader.LazyLoader()
    merge2.loadstring(data5, filename="data5.conf")
    assert merge2['something']['here!']['test']['this']['out'] == 'foo'
    config.merge(merge2)
    assert config['something']['here!']['test']['this']['out'] == 'foo'
    


def parse_keys(n):
    p = lazyloader.LazyLoader()
    return p._parse_keys(n)

def test_parse_section():
    data = [
        ('a', 'a'),
        ('a.b', 'a', 'b'),
        ('this  . that', 'this', 'that'),
        ('this...that', 'this', 'that'),
        ('foo_bar(foo_bar)', 'foobar', 'foo_bar'),
        ('A.(B).C', 'a', 'B', 'c'),
        ('A(B)C', 'a', 'B', 'c'),
        ('a ( b ) . c . d . ( e )', 'a', ' b ', 'c', 'd', ' e '),
        ]
    for trial in data:
        input = trial[0]
        output = list(trial[1:])
        assert parse_keys(input) == output
    


Node-path: tags/0.1/tests/test_nested.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 1357
Text-content-md5: 91c2ff7fac0269975db09daab63d4a4c
Text-content-sha1: c424bccee52aadd6bfad7069ced06ada37ca394e
Content-length: 1367

PROPS-END
from initools import nested
NestedDict = nested.NestedDict
from pprint import pprint

def sorted(l):
    l = l[:]
    l.sort()
    return l

def test_empty():
    d = NestedDict()
    d['a'] = 1
    assert d['a'] == 1
    d['a'] = 2
    assert d['a'] == 2
    src = {'c': 2}
    d['b'] = src
    assert d['b'] == src
    assert d['b'] is src
    assert d['b']['c'] == 2
    d2 = d.clone()
    assert d == d2
    d2['a'] = 3
    assert d.items() != d2.items()
    assert list(d.iteritems()) != list(d2.iteritems())
    print list(d.iteritems()), list(d2.iteritems())
    print d.configs, d2.configs
    assert d != d2
    assert repr(d) != repr(d2)
    assert d2['a'] == 3
    d3 = d.copy()
    assert d == d3
    assert d != None
    assert d != []
    assert d != object()

def test_nested():
    src = {
        'a': 1,
        'b': {
        'c': 2,
        'd': 3,
        }}
    shadow = {
        'b': {
        'c': 5,
        'e': 6,
        }}
    d = NestedDict([shadow, src])
    assert d['a'] == 1
    assert d['b']['c'] == 5
    assert d['b']['d'] == 3
    assert sorted(d.keys()) == ['a', 'b']
    assert sorted(d['b'].keys()) == ['c', 'd', 'e']
    assert isinstance(d['b'], NestedDict)
    concrete = {'a': 1, 'b': {'c': 5, 'd': 3, 'e': 6}}
    pprint(d)
    pprint(concrete)
    assert d == concrete

# @@: Should test docstrings in nested


Revision-number: 3
Prop-content-length: 119
Content-length: 119

K 7
svn:log
V 20
created trunk folder
K 10
svn:author
V 4
hugo
K 8
svn:date
V 27
2010-07-02T01:23:52.296155Z
PROPS-END

Node-path: trunk
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 4
Prop-content-length: 116
Content-length: 116

K 7
svn:log
V 17
added docs folder
K 10
svn:author
V 4
hugo
K 8
svn:date
V 27
2010-07-02T01:24:29.568071Z
PROPS-END

Node-path: trunk/docs
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Node-path: trunk/docs/conf.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 4081
Text-content-md5: 0d5c847fdfb77e4d221d112d921d9005
Text-content-sha1: ee7a939fef36ae446baac80b8929a45dbd4b9ef6
Content-length: 4091

PROPS-END
# -*- coding: utf-8 -*-
#
# Paste documentation build configuration file, created by
# sphinx-quickstart on Tue Apr 22 22:08:49 2008.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed automatically).
#
# All configuration values have a default value; values that are commented out
# serve to show the default value.

import sys

# If your extensions are in another directory, add it here.
#sys.path.append('some/directory')

# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.txt'

# The master toctree document.
master_doc = 'index'

# General substitutions.
project = 'INITools'
copyright = '2008, Ian Bicking'

# The default replacements for |version| and |release|, also used in various
# other places throughout the built documents.
#
# The short X.Y version.
version = '0.3'
# The full version, including alpha/beta/rc tags.
release = '0.3'

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = ['include/contact.txt', 'include/reference_header.txt']

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
html_style = 'default.css'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Content template for the index page.
#html_index = ''

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = True

# Output file base name for HTML help builder.
htmlhelp_basename = 'INIToolsdoc'


# Options for LaTeX output
# ------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, document class [howto/manual]).
#latex_documents = []

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True


Node-path: trunk/docs/index.txt
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 4153
Text-content-md5: f9c071f941b69632b7e0c273a246717f
Text-content-sha1: fc9069ef6b4bbe03aba28677c7c24fea73e77fdb
Content-length: 4163

PROPS-END
INITools
--------

.. contents::

Intro & Status
--------------

INITools is a variety of modules for manipulating ``.ini``-style
files.  This is similar to `ConfigParser
<http://python.org/doc/current/lib/module-ConfigParser.html>`_, only
easier to build on than that library.

I'm not (very) actively developing this library, though I do use it
from time to time.  Anyone interested in doing something with it
should feel free to take it in whatever direction they find
interesting.  You can contact me at ianb@colorstudy.com

Overview
--------

A whirlwind tour of the modules:

``iniparser``:
    The most basic module, this is a simple parser for ``.ini``-style
    files.  You subclass the parser and build your objects as the file
    is parsed.  See ``initools.iniparser.BasicParser`` for a minimal
    example.

``configparser``:
    A module compatible with the `standard library
    <http://python.org/doc/current/lib/module-ConfigParser.html>`__
    ``ConfigParser`` module -- it doesn't actually share any code with
    that module, but supports all the same thing plus some other
    (optional but disabled) features.

``configwrapper``:
    This offers a simple ``Config`` object that takes a single
    filename as an argument, and provides a simple interface to that
    file.  The closest thing here to ``ConfigParser``, I guess.

``lazyiniparser``:
    An ini parser that keeps complete track of the files it draws
    from, including order, filename/line number, and comments.  It can
    be used for systems that support round-tripping (reading and
    writing files).

``inischema``:
    A thought experiment, mostly.  Supports a class-based schema
    definition, and reads files matching them against the definition.
    Not terribly advanced.  It would be more interesting if it used
    `FormEncode <http://formencode.org>`_ for schemas, or maybe
    something based on (or similar to) `optparse
    <http://python.org/doc/current/lib/module-optparse.html>`_.  A
    config-file compliment to ``optparse`` would be generally useful,
    but probably would be based more on ``iniparser`` or
    ``lazyiniparser``.

``nested``:
    A nested dictionary-like object.  Lets you fold several
    dictionaries into a single view, including nested dictionaries.

``lazyloader``:
    The fanciest and most complicated of the modules.  This is where
    it seemed to get out of control (especially combined as it is with
    ``nested``).  This supports loading several files, doing
    conversion with source tracking, parsing the keys and sections to
    create highly nested structures, and folding a configuration back
    onto itself (for context-sensitive configuration).

    This is complex enough that it becomes necessary to debug your
    configuration files, which sucks.

Future
------

I don't have any particular plans, but if you do that's cool.  The
``optparse`` thing would be cool.

Other Options
-------------

See http://wiki.python.org/moin/ConfigParserShootout

News
----

svn trunk
~~~~~~~~~

* Fix to allow subclasses to implement ``error_missing_equal`` to not throw
  an error (i.e. ignore this error)

0.3
~~~

* Added ``ignore_missing_files`` configuration value on ConfigParser;
  if False (default True) then ``conf.read([filename])`` will raise an
  exception if the filename doesn't exist.

* Added an ``_open`` method on ConfigParser that can be overridden to,
  for example, support HTTP urls.

* Added ``initools.configparser.ConfigParser.write_sources(fileobj,
  sources)``, which writes all the settings in one of the sources in
  the set ``sources``.  Also
  ``initools.ConfigParser.CanonicalFilenameSet`` which is a set-like
  object that accepts relative and absolute (or case-different files
  on Windows) as the same.

* Added method ``initools.configparser.ConfigParser.setting_location(section, option)``
  which returns the (filename, line_number) of the setting (or None, None).

* Fixed a problem when writing files using inline comments, with
  ``initools.configparser.ConfigParser`` -- after parsing the wrong
  value would be put in as a comment, creating an invalid configuration file.


Node-path: trunk/docs/modules
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Node-path: trunk/docs/modules/configparser.txt
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 684
Text-content-md5: 21d2d08bba169d0e28b28d5cc134c049
Text-content-sha1: fe1a9e6b7ff586ccbcf3aff73e43b9d04407f629
Content-length: 694

PROPS-END
:mod:`initools.configparser` -- ConfigParser interface
======================================================

.. automodule:: initools.configparser

Module Contents
---------------

.. autoclass:: RawConfigParser
.. autoclass:: ConfigParser
.. autoclass:: SafeConfigParser

Exceptions
~~~~~~~~~~

.. autoexception:: Error
.. autoexception:: NoSectionError
.. autoexception:: DuplicateSectionError
.. autoexception:: NoOptionError
.. autoexception:: InterpolationError
.. autoexception:: InterpolationDepthError
.. autoexception:: InterpolationMissingOptionError
.. autoexception:: InterpolationSyntaxError
.. autoexception:: ParsingError
.. autoexception:: MissingSectionHeaderError


Node-path: trunk/docs/modules/iniparser.txt
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 270
Text-content-md5: fc6b19652f4cb3ecb47657c8a3727b40
Text-content-sha1: ae801d06f60062bc34d45d1f9121feab8d404a7d
Content-length: 280

PROPS-END
:mod:`initools.iniparser` -- Abstract parser for INI files
==========================================================

.. automodule:: initools.iniparser

Module Contents
---------------

.. autoclass:: INIParser
.. autoclass:: BasicParser
.. autoexception:: ParseError


Node-path: trunk/docs/modules/lazyiniparser.txt
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 348
Text-content-md5: c4f506117c3da0fc1247eea57218a798
Text-content-sha1: a170591a38e2a7f7455d4f5d0df8ae4f9090a7bf
Content-length: 358

PROPS-END
:mod:`initools.lazyiniparser` -- INI parser that keeps track of info
====================================================================

.. automodule:: initools.lazyiniparser

Module Contents
---------------

.. autoclass:: LazyINIParser
.. autoclass:: Configuration
.. autoclass:: Section
.. autoclass:: Item
.. autoexception:: ConversionError


Revision-number: 5
Prop-content-length: 120
Content-length: 120

K 7
svn:log
V 21
added initools folder
K 10
svn:author
V 4
hugo
K 8
svn:date
V 27
2010-07-02T01:24:53.496485Z
PROPS-END

Node-path: trunk/initools
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Node-path: trunk/initools/__init__.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 2
Text-content-md5: 552dacb15f2019c8f3f74c55befa242c
Text-content-sha1: 9762053d4defb8be822cb0957983a6b8796976d6
Content-length: 12

PROPS-END
#


Node-path: trunk/initools/_setmixin.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 2488
Text-content-md5: 36e94cb5a41d97c94bd4f14d5d899b88
Text-content-sha1: a481a1685320d0fc405d776e944a57d8e28dd395
Content-length: 2498

PROPS-END
class SetMixin(object):

    """
    Mix-in for sets.  You must define __iter__, add, remove
    """

    def __len__(self):
        length = 0
        for item in self:
            length += 1
        return length

    def __contains__(self, item):
        for has_item in self:
            if item == has_item:
                return True
        return False

    def issubset(self, other):
        for item in other:
            if item not in self:
                return False
        return True

    __le__ = issubset

    def issuperset(self, other):
        for item in self:
            if item not in other:
                return False
        return True

    __ge__ = issuperset

    def union(self, other):
        return self | other

    def __or__(self, other):
        new = self.copy()
        new |= other
        return new
    
    def intersection(self, other):
        return self & other

    def __and__(self, other):
        new = self.copy()
        new &= other
        return new

    def difference(self, other):
        return self - other

    def __sub__(self, other):
        new = self.copy()
        new -= other
        return new

    def symmetric_difference(self, other):
        return self ^ other

    def __xor__(self, other):
        new = self.copy()
        new ^= other
        return new

    def copy(self):
        return set(self)

    def update(self, other):
        for item in other:
            self.add(item)

    def __ior__(self, other):
        self.update(other)
        return self

    def intersection_update(self, other):
        for item in self:
            if item not in other:
                self.remove(item)

    def __iand__(self, other):
        self.intersection_update(other)
        return self

    def difference_update(self, other):
        for item in other:
            if item in self:
                self.remove(item)

    def __isub__(self, other):
        self.difference_update(other)
        return self

    def symmetric_difference_update(self, other):
        for item in other:
            if item in self:
                self.remove(item)
            else:
                self.add(item)

    def __ixor__(self, other):
        self.symmetric_difference_update(other)
        return self

    def discard(self, item):
        try:
            self.remove(item)
        except KeyError:
            pass

    def clear(self):
        for item in list(self):
            self.remove(item)


Node-path: trunk/initools/configparser.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 34600
Text-content-md5: 68a9e999f2a9b26d7a67ac930331baa3
Text-content-sha1: 8cd2bb90ee370e19a9ef88dcad100989b9d3b082
Content-length: 34610

PROPS-END
"""
This implements the public `ConfigParser` interface, but with some
additional enhancements.


"""

import codecs
import os
from UserDict import DictMixin
import string
from initools import iniparser
from initools._setmixin import SetMixin

class Error(Exception):
    pass

class NoSectionError(Error):
    """Exception raised when a specified section is not found."""

class DuplicateSectionError(Error):
    """Exception raised if add_section() is called with the name of a
    section that is already present."""

class NoOptionError(Error):
    """Exception raised when a specified option is not found in the
    specified section."""

class InterpolationError(Error):
    """Base class for exceptions raised when problems occur performing
    string interpolation."""

    def __init__(self, option, section, msg):
        Error.__init__(self, msg)
        self.option = option
        self.section = section

class InterpolationDepthError(InterpolationError):
    """Exception raised when string interpolation cannot be completed
    because the number of iterations exceeds
    MAX_INTERPOLATION_DEPTH. Subclass of InterpolationError."""

class InterpolationMissingOptionError(InterpolationError):
    """Exception raised when an option referenced from a value does
    not exist. Subclass of InterpolationError."""

    def __init__(self, option, section, rawval, reference, msg=None):
        if msg is None:
            msg = ("Bad value substitution:\n"
                   "\tsection: [%s]\n"
                   "\toption : %s\n"
                   "\tkey    : %s\n"
                   "\trawval : %s\n"
                   % (section, option, reference, rawval))
        InterpolationError.__init__(self, option, section, msg)
        self.reference = reference

class InterpolationSyntaxError(InterpolationError):
    """Exception raised when the source text into which substitutions
    are made does not conform to the required syntax. Subclass of
    InterpolationError."""

"""Exception raised when errors occur attempting to parse a file."""
ParsingError = iniparser.ParseError

class MissingSectionHeaderError(ParsingError):
    """Exception raised when attempting to parse a file which has no
    section headers."""

## The maximum depth for recursive interpolation for get() when the
## raw parameter is false. This is relevant only for the ConfigParser
## class.
MAX_INTERPOLATION_DEPTH = 10

class _NoDefault:
    def __repr__(self):
        return '(no default)'
_NoDefault = _NoDefault()

class RawConfigParser(object):

    # If this is true then %(DEFAULT_KEY)s will be substituted
    # in values:
    percent_expand = False
    # If this is true then ${section:value} will be substituted
    # in values:
    dollar_expand = False
    # If this is true, then .set(section_that_does_not_exist, ...)
    # will fail; otherwise the section will be implicitly created
    safe_set = False
    # If this is true then a global section is allowed (options
    # defined before any section is defined)
    global_section = False
    # If this is true, then option names are case sensitive:
    case_sensitive = False
    # If this is true, then section names are case sensitive:
    section_case_sensitive = True
    # This is the encoding to expect the file to be in:
    encoding = 'utf8'
    # If true, then comments will be allowed on the same line
    # as a value.  Otherwise comments can only be on their
    # own lines
    inline_comments = True
    # When writing a config file out, this will be used to
    # indent continuation lines:
    continuation_indent = '\t'
    # If this is true, then every section will appear to have
    # the values from [DEFAULT] in it
    inherit_defaults = True
    # This can be True or a string to indicate the name of the
    # config option for extending a section or config file.
    extendable = False
    # If extendable is True, then this value will be used:
    default_extend_name = 'extends'
    # An extends in these sections will be applied globally;
    # in other sections they will only apply to the section
    # itself
    global_extend_section_names = ['', 'global', 'DEFAULT']
    # If a extend is in a section, it will draw from some section;
    # if there is no default section then it will draw from this
    # section.  Use '__name__' to indicate the same name as the
    # section itself.
    default_extend_section_name = 'main'
    # If this is false, then if you do conf.read([filename]) and the
    # filename doesn't exist, an exception (IOError) will be raised.
    ignore_missing_files = True

    def __init__(self, defaults=None,
                 encoding=_NoDefault,
                 percent_expand=_NoDefault,
                 safe_set=_NoDefault,
                 dollar_expand=_NoDefault,
                 case_sensitive=_NoDefault,
                 section_case_sensitive=_NoDefault,
                 global_section=_NoDefault,
                 inline_comments=_NoDefault,
                 inherit_defaults=_NoDefault,
                 extendable=_NoDefault):
        if encoding is not _NoDefault:
            self.encoding = encoding
        if percent_expand is not _NoDefault:
            self.percent_expand = percent_expand
        if safe_set is not _NoDefault:
            self.safe_set = safe_set
        if dollar_expand is not _NoDefault:
            self.dollar_expand = dollar_expand
        if case_sensitive is not _NoDefault:
            self.case_sensitive = case_sensitive
        if section_case_sensitive is not _NoDefault:
            self.section_case_sensitive = section_case_sensitive
        if global_section is not _NoDefault:
            self.global_section = global_section
        if inline_comments is not _NoDefault:
            self.inline_comments = inline_comments
        if inherit_defaults is not _NoDefault:
            self.inherit_defaults = inherit_defaults
        if extendable is not _NoDefault:
            self.extendable = extendable
        if self.extendable:
            if isinstance(self.extendable, basestring):
                self._extends_name = self.extendable
            else:
                self._extends_name = self.default_extend_name
        self._pre_normalized_keys = {}
        self._pre_normalized_sections = {}
        self._key_file_positions = {}
        self._key_comments = {}
        self._section_order = []
        self._section_key_order = {}
        self._section_comments = {}
        self._values = {}
        self.add_section('DEFAULT')
        if defaults is not None:
            for name, value in defaults.items():
                self.set('DEFAULT', name, value)

    def defaults(self):
        """Return a dictionary containing the instance-wide defaults."""
        default = self.sectionxform('DEFAULT')
        return self._values.get(default, {})

    def sections(self):
        """Return a list of the sections available; DEFAULT is not
        included in the list."""
        return [self._pre_normalized_sections[sec]
                for sec in self._section_order
                if sec != self.sectionxform('DEFAULT')]

    def add_section(self, section, comment=None):
        """Add a section named section to the instance.

        If a section by the given name already exists,
        DuplicateSectionError is raised.
        """
        sec = self.sectionxform(section)
        if sec in self._values:
            if self.sectionxform('DEFAULT') == sec:
                # Ignore this one case of duplicates
                return
            raise DuplicateSectionError(
                "A section [%s] already exists"
                % sec)
        self._pre_normalized_sections[sec] = section
        if sec not in self._section_order:
            self._section_order.append(sec)
        self._section_key_order[sec] = []
        self._section_comments[sec] = comment
        self._values[sec] = {}

    def has_section(self, section):
        """Indicates whether the named section is present in the
        configuration.

        The DEFAULT section is not acknowledged.
        """
        if section == 'DEFAULT':
            return False
        return self.sectionxform(section) in self._values

    def options(self, section):
        """Returns a list of options available in the specified
        section."""
        sec = self.sectionxform(section)
        if sec not in self._values:
            raise NoSectionError(
                "Section [%s] does not exist" % sec)
        v = [self._pre_normalized_keys[(sec, op)]
             for op in self._section_key_order[sec]]
        if self.inherit_defaults and self.sectionxform('DEFAULT') != sec:
            v = v[:]
            v.extend(self.options('DEFAULT'))
        return v

    def has_option(self, section, option):
        """If the given section exists, and contains the given option,
        return True; otherwise return False."""
        sec = self.sectionxform(section)
        if self.inherit_defaults and self.sectionxform('DEFAULT') != sec:
            if self.has_option('DEFAULT', option):
                return True
        if sec not in self._values:
            return False
        return self.optionxform(option) in self._values[sec]

    def read(self, filenames, extending=False, map_sections=None):
        """Attempt to read and parse a list of filenames, returning a
        list of filenames which were successfully parsed.

        If filenames is a string or Unicode string, it is treated as a
        single filename. If a file named in filenames cannot be
        opened, that file will be ignored. This is designed so that
        you can specify a list of potential configuration file
        locations (for example, the current directory, the user's home
        directory, and some system-wide directory), and all existing
        configuration files in the list will be read. If none of the
        named files exist, the ConfigParser instance will contain an
        empty dataset. An application which requires initial values to
        be loaded from a file should load the required file or files
        using readfp() before calling read() for any optional files:

          import ConfigParser, os

          config = ConfigParser.ConfigParser()
          config.readfp(open('defaults.cfg'))
          config.read(['site.cfg', os.path.expanduser('~/.myapp.cfg')])

        If ``extending`` is true (default false) then the values
        picked up from the file will *not* override the values already
        present (that means that the file being loaded is extended by
        the already loaded file).
        """
        found = []
        if isinstance(filenames, basestring):
            filenames = [filenames]
        for fn in filenames:
            try:
                fp = self._open(fn)
            except IOError, e:
                if not self.ignore_missing_files:
                    raise
                continue
            found.append(fn)
            try:
                self.readfp(fp, fn, extending=extending,
                            map_sections=map_sections)
            finally:
                fp.close()
        return found

    def _open(self, filename, mode='r'):
        """
        Open a file.  You can override this in a subclass to, for
        example, allow loading configs over HTTP.
        """
        return open(filename, mode)

    def readfp(self, fp, filename='<???>', extending=False,
               map_sections=None):
        """Read and parse configuration data from the file or
        file-like object in fp

        Only the readline() method is used. If filename is omitted and
        fp has a name attribute, that is used for filename; the
        default is '<???>'.
        """
        parser = _ConfigParserParser(self, extending=extending,
                                     map_sections=map_sections)
        parser.loadfile(fp, filename=filename,
                        encoding=self.encoding)
        if self.extendable:
            self._process_extends()

    def _process_extends(self):
        """
        Figure out if there's any extends options in the config
        file, and if so then process those options and remove them.
        """
        extend = self.optionxform(self._extends_name)
        glob_sections = map(
            self.sectionxform, self.global_extend_section_names)
        reads = []
        for section, values in self._values.iteritems():
            if extend in values:
                value = self.getfilename(section, extend)
                if self.sectionxform(section) in glob_sections:
                    reads.append((value, None))
                else:
                    if '#' in value:
                        value, inc_section = value.split('#', 1)
                    else:
                        inc_section = self.default_extend_section_name
                    if inc_section == '__name__':
                        inc_section = section
                    reads.append((value, {inc_section: section}))
                self.remove_option(section, extend)
        for filename, map_sections in reads:
            self.read(filename, extending=True,
                      map_sections=map_sections)

    def get(self, section, option, raw=False, vars=None, _recursion=0):
        """Get an option value for the named section.

        If self.percent_expand is true, then all the '%'
        interpolations are expanded, using the optional vars.  If raw
        is True, then no interpolation is done."""
        if _recursion > MAX_INTERPOLATION_DEPTH:
            raise InterpolationDepthError(
                section, option,
                "Maximum recursion depth for interpolation exceded")
        sec = self.sectionxform(section)
        op = self.optionxform(option)
        if sec not in self._values:
            raise NoSectionError(
                "Section [%s] not found (when looking for option %r)"
                % (section, option))
        values = self._values[sec]
        if op not in values:
            if (self.inherit_defaults
                and self.sectionxform('DEFAULT') != sec
                and self.has_option('DEFAULT', op)):
                value = self.get('DEFAULT', op, raw=True)
            else:
                raise NoOptionError(
                    "Option %r not found (in section [%s])"
                    % (option, section))
        else:
            value = values[op]
        if raw:
            return value
        if self.percent_expand:
            value = self._do_percent_expansion(
                section, option, value, vars, _recursion)
        if self.dollar_expand:
            value = self._do_dollar_expansion(
                section, option, value, vars, _recursion)
        return value

    def _do_percent_expansion(self, section, option, value,
                              vars, _recursion):
        if vars is None:
            vars = {}
        vars = _OptionWrapper(self, vars, section, option, _recursion)
        if not isinstance(value, basestring):
            raise TypeError(
                "Cannot interpolate a non-string [%s] option %s=%r"
                % (section, option, value))
        try:
            return value % vars
        except KeyError, e:
            var = e.args[0]
            raise InterpolationMissingOptionError(
                option, section, value, var,
                "Variable %s not found in [%s] option %s=%s%s"
                % (var, section, option, value,
                   self._get_location_info(section, option)))
        except ValueError, e:
            raise InterpolationSyntaxError(
                option, section,
                "%s in [%s] option %s=%s%s"
                % (e, section, option, value,
                   self._get_location_info(section, option)))

    def _do_dollar_expansion(self, section, option, value,
                             vars, _recursion):
        if vars is None:
            vars = {}
        vars = _SectionOptionWrapper(self, vars, section, option, _recursion)
        if not isinstance(value, basestring):
            raise TypeError(
                "Cannot interpolate a non-string [%s] option %s=%r"
                % (section, option, value))
        try:
            tmpl = string.Template(value)
            return tmpl.substitute(vars)
        except KeyError, e:
            var = e.args[0]
            raise InterpolationMissingOptionError(
                option, section, value, var,
                "Variable %s not found in [%s] option %s=%s%s"
                % (var, section, option, value,
                   self._get_location_info(section, option)))
        except ValueError, e:
            raise InterpolationSyntaxError(
                option, section,
                "%s in [%s] option %s=%s%s"
                % (e, section, option, value,
                   self._get_location_info(section, option)))

    def _get_location_info(self, section, option):
        location = self.setting_location(section, option)
        if location[0]:
            extra = ' (located at %s' % location[0]
            if location[1]:
                extra += ':%s' % location[1]
            extra += ')'
        else:
            extra = ''
        return extra

    def setting_location(self, section, option):
        """
        Returns (filename, line_number) where the given setting was defined.
        May return (None, None) if it's unknown.
        """
        location = self._key_file_positions.get(
            (self.sectionxform(section), self.optionxform(option)),
            (None, None))
        return location

    def getint(self, section, option):
        """A convenience method which coerces the option in the
        specified section to an integer."""
        value = self.get(section, option)
        try:
            return int(value)
        except ValueError:
            loc_info = self._get_location_info(section, option)
            raise ValueError(
                "Could not convert option %s=%s (in [%s]) to an integer%s"
                % (option, value, section, loc_info))

    def getfloat(self, section, option):
        """A convenience method which coerces the option in the
        specified section to a floating point number."""
        value = self.get(section, option)
        try:
            return float(value)
        except ValueError:
            raise ValueError(
                "Could not convert options %s=%s (in [%s]) to a float%s"
                % (option, value, section,
                   self._get_location_info(section, option)))

    def getboolean(self, section, option):
        """A convenience method which coerces the option in the
        specified section to a Boolean value.

        Note that the accepted values for the option are "1", "yes",
        "true", and "on", which cause this method to return True, and
        "0", "no", "false", and "off", which cause it to return
        False. These string values are checked in a case-insensitive
        manner. Any other value will cause it to raise ValueError.
        """
        value = self.get(section, option)
        value = value.strip().lower()
        if value in ('1', 'y', 'yes', 't', 'true', 'on'):
            return True
        elif value in ('0', 'n', 'no', 'f', 'false', 'off'):
            return False
        raise ValueError(
            "Could not convert option %s=%s (in [%s] to a boolean "
            "(use true/false)%s"
            % (option, value, section,
               self._get_location_info(section, option)))

    def getfilename(self, section, option):
        """Returns the value of the option, interpreted as a filename
        relative to the location of where the option was defined.

        Raises a ValueError if the option doesn't have an associated
        filename and the path is not absolute.
        """
        value = self.get(section, option)
        filename = self.setting_location(section, option)[0]
        if filename is None:
            if os.path.isabs(value):
                return value
            raise ValueError(
                "Getting relative filename [%s] option %s=%s , but there "
                "is no recorded config file for option"
                % (section, option, value))
        value = os.path.join(os.path.dirname(filename), value)
        return value

    def items(self, section, raw=False, vars=None):
        """Return a list of (name, value) pairs for each option in the
        given section.

        If self.percent_expand is true, then all the '%'
        interpolations are expanded, using the optional vars.  If raw
        is True, then no interpolation is done.
        """
        result = []
        for op in self.options(section):
            result.append((op, self.get(section, op, raw=raw, vars=vars)))
        return result

    def allitems(self, raw=False, vars=None):
        result = {}
        for section in self.sections():
            result[section] = self.items(section, raw=raw, vars=vars)
        return result
        
    def set(self, section, option, value, filename=None,
            line_number=None, comments=None):
        """If the given section exists, set the given option to the
        specified value; otherwise raise NoSectionError.

        While it is possible to use RawConfigParser (or ConfigParser
        with raw parameters set to true) for internal storage of
        non-string values, full functionality (including interpolation
        and output to files) can only be achieved using string values.

        If self.safe_set is true, then only string values will be
        allowed.
        """
        if not isinstance(value, basestring) and self.safe_set:
            raise TypeError(
                "You can only set options to string values "
                "(you tried to set %s=%r in [%s])"
                % (option, value, section))
        sec = self.sectionxform(section)
        if sec not in self._values:
            raise NoSectionError(
                'There is no section [%s] (when setting option %r)'
                % (sec, option))
        op = self.optionxform(option)
        self._pre_normalized_keys[(sec, op)] = option
        if op in self._section_key_order[sec]:
            self._section_key_order[sec].remove(op)
        self._section_key_order[sec].append(op)
        if comments is None:
            if (sec, op) in self._key_comments:
                del self._key_comments[(sec, op)]
        else:
            self._key_comments[(sec, op)] = comments
        if filename is None:
            if (sec, op) in self._key_file_positions:
                del self._key_file_positions[(sec, op)]
        else:
            self._key_file_positions[(sec, op)] = (filename, line_number)
        self._values[sec][op] = value

    def write(self, fileobject):
        """Write a representation of the configuration to the
        specified file object.

        This representation can be parsed by a future read() call.
        """
        self.write_sources(fileobject, None)

    def write_sources(self, fileobject, sources):
        """Write a representation of the configuration, but filtered
        to only include configuration that came from `sources`.

        `sources` should be a set-like object (support ``in``) and
        any setting that came from a source included in this set will
        be written out.  Note that None is a valid source, and typical
        for settings written with ``parser.set(section, option, value)``.

        If `sources` is None, that means include settings from all
        sources.

        Note that you should be careful about non-canonical filenames.
        For instance, if a file was loaded with a relative filename,
        then you give a set that includes the same filename but in an
        absolute form, this function will not recognize them as the
        same.
        """
        f = fileobject
        if self.encoding:
            # @@: output encoding, errors?
            f = codecs.EncodedFile(f, self.encoding)
        for sec in self._section_order:
            section = self._pre_normalized_sections[sec]
            ops = self._section_key_order[sec]
            selected_ops = []
            for op in ops:
                location = self.setting_location(sec, op)
                if (sources is None
                    or location[0] in sources):
                    selected_ops.append(op)
            if not selected_ops and sources is not None:
                # Nothing in the section (at least for this file)
                continue
            comment = self._section_comments.get(sec)
            if comment:
                f.write(comment+'\n')
            f.write('[%s]\n' % section)
            for op in selected_ops:
                option = self._pre_normalized_keys[(sec, op)]
                comment = self._key_comments.get((sec, op))
                if comment:
                    f.write(comment+'\n')
                f.write('%s = ' % option)
                lines = self._values[sec][op].splitlines()
                if not lines:
                    lines = ['']
                f.write(lines[0])
                for line in lines[1:]:
                    f.write('\n%s%s' % (self.continuation_indent, line))
                f.write('\n')
                if comment:
                    f.write('\n')
            f.write('\n')

    def remove_option(self, section, option):
        """Remove the specified option from the specified section.

        If the section does not exist, raise NoSectionError. If the
        option existed to be removed, return True; otherwise return
        False.
        """
        sec = self.sectionxform(section)
        if sec not in self._values:
            raise NoSectionError(
                'No section [%s] (while trying to remove %r)'
                % (section, option))
        op = self.optionxform(option)
        if op in self._values[sec]:
            del self._values[sec][op]
            del self._pre_normalized_keys[(sec, op)]
            if (sec, op) in self._key_comments:
                del self._key_comments[(sec, op)]
            if (sec, op) in self._key_file_positions:
                del self._key_file_positions[(sec, op)]
            self._section_key_order[sec].remove(op)
            return True
        else:
            return False

    def remove_section(self, section):
        """Remove the specified section from the configuration.

        If the section in fact existed, return True. Otherwise return
        False.
        """
        sec = self.sectionxform(section)
        if sec not in self._values:
            return False
        for key in self._pre_normalized_keys:
            if key[0] == sec:
                del self._pre_normalized_keys[key]
        del self._pre_normalized_sections[sec]
        for key in self._key_file_positions:
            if key[0] == sec:
                del self._key_file_positions[key]
        for key in self._key_comments:
            if key[0] == sec:
                del self._key_comments[key]
        self._section_order.remove(sec)
        del self._section_key_order[sec]
        if sec in self._section_comments:
            del self._section_comments[sec]
        del self._values[sec]

    def optionxform(self, option):
        """Transforms the option name option as found in an input file
        or as passed in by client code to the form that should be used
        in the internal structures.

        The default implementation returns a lower-case version of
        option; subclasses may override this or client code can set an
        attribute of this name on instances to affect this
        behavior. Setting this to str(), for example, would make
        option names case sensitive.
        """
        if not self.case_sensitive:
            return option.lower()
        else:
            return option

    def sectionxform(self, option):
        """Transforms the section name option as found in an input file
        or as passed in by client code to the form that should be used
        in the internal structures.

        The default implementation returns a lower-case version of
        option; subclasses may override this or client code can set an
        attribute of this name on instances to affect this
        behavior. Setting this to str(), for example, would make
        option names case sensitive.
        """
        if not self.section_case_sensitive:
            return option.lower()
        else:
            return option

    def asdict(self):
        return self._values.copy()

    def sectiondict(self, section):
        return self._values.get(self.sectionxform(section), {}).copy()

class ConfigParser(RawConfigParser):

    percent_expand = True

class SafeConfigParser(ConfigParser):

    safe_set = True

class _ConfigParserParser(iniparser.INIParser):
    """
    This parser feeds the parsed values into a ConfigParser object
    """

    def __init__(self, cp, extending, map_sections=None):
        self.cp = cp
        self.extending = extending
        self.map_sections = map_sections
        self.last_comment = None
        self.section = None

    def assignment(self, name, content):
        if self.section is None and not self.cp.global_section:
            self.parse_error("Missing Section",
                             exception=MissingSectionHeaderError)
        content = content.strip(' \t')
        if not name:
            self.parse_error('No name given for option')
        if self.cp.inline_comments:
            lines = content.splitlines()
            result = []
            for line in lines:
                semi_pos = line.find(';')
                hash_pos = line.find('#')
                if semi_pos == -1 and hash_pos == -1:
                    comment = None
                elif semi_pos == -1:
                    line, comment = line.split('#', 1)
                    comment_char = '#'
                elif hash_pos == -1:
                    line, comment = line.split(';', 1)
                    comment_char = ';'
                elif hash_pos < semi_pos:
                    line, comment = line.split('#', 1)
                    comment_char = '#'
                else:
                    line, comment = line.split(';', 1)
                    comment_char = ';'
                if comment is not None:
                    line = line.rstrip()
                    comment = comment_char + ' ' + comment.lstrip()
                    self.add_comment(comment)
                result.append(line)
            content = '\n'.join(result)
        if self.extending:
            if self.cp.has_option(self.section, name):
                # Don't write over options
                return
        if self.map_sections is not None:
            if self.section in self.map_sections:
                section = self.map_sections[self.section]
            else:
                return
        else:
            section = self.section
        self.cp.set(
            section, name, content,
            filename=self.filename,
            line_number=self.lineno,
            comments=self.last_comment)
        self.last_comment = None

    def new_section(self, section):
        if not self.cp.has_section(section):
            self.cp.add_section(section, comment=self.last_comment)
            self.last_comment = None
        if not section:
            self.parse_error('Empty section name ([])')
        self.section = section
        
    def add_comment(self, comment):
        if self.last_comment is None:
            self.last_comment = comment
        else:
            self.last_comment = self.last_comment + '\n' + comment


class _OptionWrapper(DictMixin):

    """
    This produces the dictionary used for percent substitution in
    values.

    Substitution is recursive.
    """

    def __init__(self, parser, extra_vars, section, option,
                 _recursion):
        self.parser = parser
        self.extra_vars = extra_vars
        self.normal_extra_vars = {}
        for name, value in extra_vars.iteritems():
            self.normal_extra_vars[parser.optionxform(name)] = value
        self.section = section
        self.option = option
        self._recursion = _recursion

    def __getitem__(self, item):
        if item == '__name__':
            return self.section
        item = self.parser.optionxform(item)
        if item in self.normal_extra_vars:
            return self.normal_extra_vars[item]
        if self.parser.has_option(self.section, item):
            return self.parser.get(self.section, item,
                                   vars=self.extra_vars,
                                   _recursion=self._recursion+1)
        if item in self.parser.defaults():
            return self.parser.defaults()[item]
        raise KeyError(item)
        
class _SectionOptionWrapper(_OptionWrapper):
    """
    This provides the dict wrapper for dollar substitution.  Unlike
    percent substitution, you can reference values from arbitrary
    sections.
    """

    def __getitem__(self, item):
        if ':' in item:
            # Explicit section:
            section, item = item.split(':', 1)
            return self.parser.get(section, item, vars=self.extra_vars,
                                   _recursion=self._recursion+1)
        return _OptionWrapper.__getitem__(self, item)
    
class CanonicalFilenameSet(object):
    """
    This wrapper for a set will make sure that canonical filenames are
    used when checking for containment.

    That is, if you test ``'foo/bar' in
    CanonicalFilenameSet(['/home/user/foo/bar'])`` if the current
    working directory is ``'/home/usr/'`` then this would return True.

    This makes a filename canonical using os.path.abspath and
    os.path.normcase.
    """

    def __init__(self, s=None):
        self.set = set()
        if s is not None:
            for item in s:
                self.add(item)

    def canonical(self, item):
        if not isinstance(item, basestring):
            return item
        return os.path.normcase(os.path.abspath(item))

    def __repr__(self):
        return 'CanonicalFilenameSet(%r)' % list(self.set)

    def __contains__(self, other):
        return self.canonical(other) in self.set

    def __iter__(self):
        return iter(self.set)

    def add(self, item):
        self.set.add(self.canonical(item))

    def remove(self, item):
        self.set.remove(self.canonical(item))


Node-path: trunk/initools/configwrapper.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 8550
Text-content-md5: 970b7288710007798fd397c510d11046
Text-content-sha1: fc9c33bc16b97d410bb993e2f29fdd9ebd3f2ec3
Content-length: 8560

PROPS-END
"""
**Deprecated** (13 Aug 2006)
"""

# This was deprecated 13 Aug 2006
import warnings
warnings.warn('initools.configwrapper is not supported or recommended for use.',
              DeprecationWarning)


import os
import iniparser

class _ConfigParser(iniparser.INIParser):

    """
    An internal subclass of the abstract ini parser, which saves
    everything into one dictionary.
    """

    def __init__(self, allow_empty_sections=True):
        self.allow_empty_sections = allow_empty_sections
        iniparser.INIParser.__init__(self)

    def reset(self):
        self.data = {}
        self.key_order = {}
        self.section_order = []
        iniparser.INIParser.reset(self)

    def assignment(self, name, content):
        section = self.data.setdefault(self.section, {})
        name = clean_name(name)
        section.setdefault(name, []).append(content)
        self.key_order.setdefault(self.section, []).append(name)

    def new_section(self, section):
        section = section.strip().lower()
        if not section or section == 'general':
            section = None
        self.section = section
        if not section in self.section_order:
            self.section_order.append(section)

class NoDefault:
    pass

def clean_name(name):
    name = name.strip().lower()
    for char in ' \t_-':
        name = name.replace(char, '')
    return name

class Config(object):

    """
    A configuration object.  Acts a little like a dictionary, but not
    really.

    Configuration can be nested with ``[section]`` markers, or can be
    flat (everything globally available).  If in sections then
    ``section.key`` is used, otherwise just ``key``.
    """

    # If False, then no global sections are allowed
    allow_empty_sections = True

    def __init__(self, filename, file=None,
                 allow_empty_sections=NoDefault):
        if allow_empty_sections is not NoDefault:
            self.allow_empty_sections = allow_empty_sections
        self.filename = filename
        p = _ConfigParser(allow_empty_sections=self.allow_empty_sections)
        if file is None:
            p.load(filename)
        else:
            p.loadfile(file)
        self.raw_data = p.data
        self._section_order = p.section_order
        self._key_order = p.key_order
        self.name = os.path.splitext(os.path.basename(filename))[0]

    def keys(self, section=NoDefault):
        if section is NoDefault:
            all = []
            for section_name in self._section_order:
                for key_name in self._key_order[section_name]:
                    if section_name:
                        key_name = '%s|%s' % (section_name, key_name)
                    all.append(key_name)
            return all
        else:
            try:
                return self._key_order[section]
            except KeyError:
                raise KeyError(
                    "Section [%s] not found (from sections %r)"
                    %(section, self._key_order.keys()))

    def sections(self):
        return self._section_order

    def getraw(self, key, section=None):
        """
        Mostly for internal use, returns a list of all matching keys.
        """
        if '|' in key:
            assert section is None, (
                "Cannot have | in a key (%r) and an explicit section (%r)"
                % (key, section))
            section, key = key.split('|', 1)
        section = self.clean_section(section)
        try:
            return self.raw_data[section][key]
        except KeyError:
            return ()

    def clean_section(self, section_name):
        if not section_name or section_name == 'general':
            return None
        return section_name.lower()

    def get(self, key, default=None, section=None):
        """
        Get a single value, returning `default` if none found.
        """
        value = self.getraw(key, section=section)
        if not value:
            return default
        else:
            return value[0]

    def getlist(self, key, default=(), section=None):
        """
        Get a list of all matching keys.  Example::

          foo = bar
          foo = baz

        Then::

          >>> config.getlist('foo')
          ['bar', 'baz']
        """
        value = self.getraw(key, section=section)
        if not value:
            return default
        else:
            return value

    true_values = ['t', 'true', '1', 'y', 'yes', 'on']
    false_values = ['f', 'false', '0', 'n', 'no', 'off']

    def getbool(self, key, default=False, section=None):
        """
        Get a single boolean value.  Boolean values are things
        like ``true``, ``false``, etc.
        """
        value = self.getraw(key, section=section)
        if not value:
            return default
        value = value[0]
        if isinstance(value, (str, unicode)):
            value = value.lower()
            if value in self.true_values:
                return True
            elif value in self.false_values:
                return False
            else:
                raise ValueError(
                    "Yes/No value expected for %s (got %r)"
                    % (key, value))
        else:
            return value

    def getint(self, key, default=None, section=None):
        """
        Get an integer value.
        """
        v = self.get(key, default=default, section=section)
        if v is None:
            return v
        else:
            return int(v)
        
    def getinlinelist(self, key, default=(), section=None):
        """
        Get a list, where the list is defined like::

            foo = bar, baz

        Gives::

            >>> config.getinlinelist('foo')
            ['bar', 'baz']
        """
        result = []
        for item in self.getlist(key, default, section):
            item = item.strip()
            if not item:
                continue
            if ',' in item:
                result.extend([i.strip() for i in item.split(',')])
            else:
                result.append(item)
        return result

    def getstartswith(self, startswith, section):
        """
        Returns a list of ``[(key, value), ...]`` for all keys in the
        section that start with startswith.
        """
        result = []
        for key in self.keys(section=section):
            if not key.startswith(startswith):
                continue
            for value in self.getraw(key, section=section):
                result.append((key, value))
        return result

    def __repr__(self):
        return '<%s filename=%s>' % (
            self.__class__.__name__, self.filename)

    def __str__(self):
        data = []
        data.append('%s from %s:' % (
            self.__class__.__name__, self.filename))
        for name, value_list in self.raw_data.get(None, {}).items():
            for value in value_list:
                data.append('%s: %s' % (name, value))
        for section_name, value_dict in self.raw_data.items():
            if section_name is None:
                continue
            data.append('[%s]' % section_name)
            for name, value_list in value_dict.items():
                for value in value_list:
                    data.append('%s: %s' % (name, value))
        return '\n'.join(data)
                
def load_options(parser, options, config, if_exists=True):
    """
    Given a parser object and the parsed options and a configuration
    object or filename, this will load the configuration into the
    parsed options.
    """
    types = {}
    dests = {}
    aliases = {}
    for option in parser.option_list:
        if not option.dest:
            # Some builtin options, like --help
            continue
        name = clean_name(option.dest)
        dests[name] = option.dest
        if option.action in ('store_true', 'store_false'):
            types[name] = 'getbool'
        else:
            types[name] = 'get'
        for lst in option._long_opts, option._short_opts:
            for opt in lst:
                aliases[clean_name(opt)] = name
    if isinstance(config, str):
        if if_exists and not os.path.exists(config):
            return
        config = Config(config)
    for config_key in config.keys():
        name = aliases.get(config_key, config_key)
        if name not in dests:
            raise ValueError(
                "Bad configuration file: option %r unexpected" % config_key)
        value = getattr(config, types[name])(config_key)
        setattr(options, dests[name], value)

        


Node-path: trunk/initools/iniparser.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 8097
Text-content-md5: 0fdd66d2a24b6a0d7160a4eeb39ea8af
Text-content-sha1: 9f74fd5785cabb35f830a4af844481b5ade83112
Content-length: 8107

PROPS-END
"""
A parser for .ini-syntax files.  INIParser should be subclassed to
create a data structure from the file.  See INIParser for more
"""

class ParseError(Exception):

    def __init__(self, message, filename=None, lineno=None, column=None, line=None):
        # Note: right now column is not used, but in some contexts it
        # could be used to print out a line like:
        # error, must be an integer:
        # a = one
        #     ^
        self.message = message
        self.filename = filename
        self.lineno = lineno
        self.column = column
        self.line = line

    def __str__(self):
        msg = self.message
        if self.filename and self.lineno:
            msg += ' in %s:%s' % (self.filename, self.lineno)
        elif self.filename:
            msg += ' in %s' % self.filename
        elif self.lineno:
            msg += ' at line %s' % self.lineno
        return msg

class INIParser(object):

    """
    A parser for .ini-syntax files.

    Implements all features I know of in .ini files:

    * sections with a [ in the first column
    * assignment via a=b or a: b
    * rfc822-style continuation lines (i.e., start the next line
      with indentation to make it a continuation).
    * ; or # for comments

    This class should be subclassed.  Subclasses may only need to
    implement the .assignment() method.  You may want to use the
    .section attribute, which holds the current section (or None if no
    section has been defined yet).

    Use .parse_error(message) when you encounter a problem; this will
    create an exception that will note the filename and line in which
    the problem occurs.
    """

    def __init__(self):
        self.reset()

    def reset(self):
        pass

    def load(self, filename, encoding=None):
        fileobj = open(filename, 'rb')
        self.loadfile(fileobj, filename=filename, encoding=encoding)
        fileobj.close()

    def loadfile(self, fileobj, filename=None, encoding=None):
        self.start_lineno = 0
        if filename is None:
            filename = getattr(fileobj, 'name', None)
        self.filename = filename
        # lineno is what we are parsing, start_lineno is the last
        # assignment we processed (for multi-line assignments)
        self.start_lineno = 0
        self.lineno = 0
        self.encoding = encoding
        def strip_newline(l):
            if l.endswith('\n'):
                return l[:-1]
            else:
                return l
        self.stream = [strip_newline(l) for l in fileobj.readlines()]
        self.process_file()
        del self.filename
        del self.encoding
        del self.lineno

    def loadstring(self, string, filename=None):
        self.stream = string.splitlines()
        self.filename = filename
        self.start_lineno = 0
        self.lineno = 0
        self.encoding = None
        self.process_file()
        del self.stream
        del self.filename
        del self.lineno
        del self.encoding

    def process_file(self):
        self.section = None
        last_name = None
        accumulated_content = None
        for line in self.stream:
            self.lineno += 1
            # @@: should catch encoding error:
            if self.encoding:
                line = line.decode(self.encoding)
            end_assignment = False
            if not line.strip(): # empty line
                if last_name is not None:
                    self.process_assignment(
                        last_name,
                        accumulated_content)
                    last_name = accumulated_content = None
                    self.start_lineno = self.lineno
                continue
            elif line[0] in (' ', '\t'): # continuation line
                if not last_name:
                    self.error_continuation_without_assignment(line)
                else:
                    accumulated_content.append(line)
                continue
            elif self.get_section(line) is not None: # section line
                if last_name is not None:
                    self.process_assignment(
                        last_name,
                        accumulated_content)
                    last_name = accumulated_content = None
                    self.start_lineno = self.lineno
                self.new_section(self.get_section(line))
            elif self.get_comment(line) is not None: # comment line
                if last_name is not None:
                    self.process_assignment(
                        last_name,
                        accumulated_content)
                    last_name = accumulated_content = None
                    self.start_lineno = self.lineno
                self.add_comment(self.get_comment(line))
            else: # normal assignment
                if last_name is not None:
                    self.process_assignment(
                        last_name,
                        accumulated_content)
                last_name, accumulated_content = self.split_name_value(line)
                self.start_lineno = self.lineno
        if last_name is not None:
            self.process_assignment(
                last_name,
                accumulated_content)

    def split_name_value(self, line):
        colon_pos = line.find(':')
        equal_pos = line.find('=')
        if colon_pos == -1 and equal_pos == -1:
            self.error_missing_equal(line)
            return None, None
        if (colon_pos == -1
            or (equal_pos != -1 and equal_pos < colon_pos)):
            pos = equal_pos
        else:
            pos = colon_pos
        return line[:pos], [line[pos+1:]]

    def get_comment(self, line):
        """
        Returns None if not a comment
        """
        line = line.lstrip()
        if line.startswith(';') or line.startswith('#'):
            return line[1:]
        return None

    def get_section(self, line):
        """
        Returns None if not a section
        """
        line = line.strip()
        if not line.startswith('['):
            return None
        if not line.endswith(']'):
            self.error_section_without_end_bracket(line)
            return None
        return line[1:-1]
                        
    def process_assignment(self, name, accumulated_content):
        content = '\n'.join([l.lstrip() for l in accumulated_content])
        self.assignment(name.strip(), content)

    def assignment(self, name, content):
        raise NotImplementedError

    def new_section(self, section):
        if not section:
            self.error_no_section_name()
        self.section = section

    def add_comment(self, comment):
        pass

    def error_continuation_without_assignment(self, line):
        self.parse_error('Invalid indentation', line)

    def error_section_without_end_bracket(self, line):
        self.parse_error('Invalid section (must end with ])', line)

    def error_missing_equal(self, line):
        self.parse_error(
            'Lines should look like "name=value" or "name: value"',
            line)

    def error_no_section_name(self):
        self.parse_error(
            'Empty section name ([])')

    def parse_error(self, msg, line=None, exception=None):
        if exception is None:
            exception = ParseError
        raise exception(
            msg,
            filename=self.filename,
            lineno=self.lineno,
            line=line)

class BasicParser(INIParser):

    """
    A simple subclass of INIParser; creates a nested data structure
    like ``{'section_name': {'variable': ['values']}}``

    Usage::

        >>> p = BasicParser()
        >>> p.load('config.ini')
        >>> data = p.data
    """

    def reset(self):
        self.data = {}
        INIParser.reset(self)

    def assignment(self, name, content):
        if not self.section:
            self.parse_error(
                'Assignments can only occur inside sections; no section has been defined yet')
        section = self.data.setdefault(self.section, {})
        section.setdefault(name, []).append(content)
        
    


Node-path: trunk/initools/inischema.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 13460
Text-content-md5: 11ec615fc3bfc25a7c2b42e8c4d92521
Text-content-sha1: 24bdba1d861aa94b581226806d252331acaba5d7
Content-length: 13470

PROPS-END
"""
**Probably will be deprecated** (13 Aug 2006): I'm not sure if this
is worth keeping around.


.ini file schemas

You can define a schema for your .ini configuration files, which
defines the types and defaults for the values.  You can also define
a catchall attribute.

TODO
----

Currently, this does not deal with sections at all, and sections are
not allowed.  That wil take some more thought, as the schemas will
probably be per-section (though one section may inherit from another,
or defaults may be inherited, etc, which should be allowed for).

Documentation isn't kept track of, nor is it generated.  It should
possible to indicate with ``opt(help=...)``, and as an option
to ``INISchema.ini_repr()`` you should be able to put in documentation
in comments.

Comments aren't kept track of.

Key order isn't kept track of.

Minimal .ini files should be possible to generate -- only generating
keys when the default doesn't match the actual value.

There should be a way to check that the entire config is loaded, and
there are no missing values (options which weren't set and have no
default).

Usage
-----

::

    class VHostSchema(INISchema):

        server_name = opt()
        port = optint(default=80)
        # optlist means this can show up multiple times:
        server_alias = optlist(default=[])
        document_root = opt()

    vhost = VHostSchema()
    vhost.load('config.ini')
    connect(vhost.server_name, vhost.port)
    # etc.

Any schema can contain an ``optdefault()`` object, which will
pick up any keys that aren't specified otherwise (if not present,
extra keys are an error).  Then you'll get a dictionary of lists,
for all the extra config values.  (Use
``optdefault(allow_multiple=False)`` if you want a dictionary of
strings).

If you expect multiple values, use ``optlist(subtype=optsomething())``
for a key.  The values will be collected in a list; if you don't
indicate ``subtype`` then ``opt()`` is used.  Other types are
fairly easy to make through subclassing.

You can generate config files by using ``schema.ini_repr()`` which
will return a string version of the ini file.

Implementation
--------------

This makes heavy use of descriptors.  If you are not familiar with
descriptors, see http://users.rcn.com/python/download/Descriptor.htm

It also makes light use of metaclasses.
"""


import iniparser

class INIMeta(type):

    def __new__(meta, class_name, bases, d):
        cls = type.__new__(meta, class_name, bases, d)
        cls.__classinit__.im_func(cls, d)
        return cls

class ParseValueError(Exception):
    pass

class NoDefault:
    pass

class INISchema(object):

    __metaclass__ = INIMeta

    _default_option = None
    _default_values = None

    _config_names = {}
    _config_names_lower = {}

    case_insensitive = False

    def __classinit__(cls, d):
        # We don't initialize INISchema itself:
        if cls.__bases__ == (object,):
            return
        cls._config_names = cls._config_names.copy()
        cls._config_names_lower = cls._config_names_lower.copy()
        for name, value in d.items():
            if isinstance(value, opt):
                cls.add_option(name, value)
        # @@: We should look for None-ified options, and remove
        # them from cls._config_names

    def add_option(cls, attr_name, option):
        """
        Classmethod: add the option using the given attribute name.
        This can be called after the class has been created, to
        dynamically build up the options.
        """
        if isinstance(option, optdefault):
            # We use a list so that the descriptor behavior doesn't
            # apply here:
            cls._default_option = [option]
            option.attr_name = attr_name
            return
        if option.names is None:
            option.names = [attr_name]
        option.attr_name = attr_name
        for option_name in option.names:
            cls._config_names[option_name] = option
            cls._config_names_lower[option_name.lower()] = option
        option.set_schema(cls)
        setattr(cls, attr_name, option)

    add_option = classmethod(add_option)

    def __init__(self):
        self._ini_attrs = {}

    def set_config_value(self, name, value):
        if self.case_insensitive:
            name = name.lower()
            config_names = self._config_names_lower
        else:
            config_names = self._config_names
        if config_names.has_key(name):
            setattr(self, config_names[name].attr_name, value)
        elif not self._default_option:
            raise ParseValueError(
                "The setting %r was not expected (from %s)"
                % (name, ', '.join(config_names.keys()) or 'none'))
        else:
            self._default_option[0].set_config_value(
                self, name, value)

    def _parser(self):
        return SchemaINIParser(self)

    def load(self, filename, **kw):
        """
        Loads the filename.  Use the encoding keyword argument to
        specify the file's encoding.
        """
        self._parser().load(filename, **kw)

    def loadstring(self, string, **kw):
        """
        Loads the string, which is the content of the ini files.
        Use the filename keyword argument to indicate the filename
        source (or another way to identify the source of the string
        in error messages).
        """
        self._parser().loadstring(string, **kw)

    def as_dict(self, fold_defaults=False):
        """
        Returns the loaded configuration as a dictionary.
        """
        # @@: default values won't show up here
        v = self._ini_attrs.copy()
        if fold_defaults:
            if self._default_values:
                v.update(self._default_values)
        elif self._default_option:
            v[self._default_option[0].attr_name] = self._default_values or {}
        return v

    def ini_repr(self):
        """
        Returns the loaded values as a string, suitable as a
        configuration file.
        """
        config_names = []
        used_options = {}
        for option in self._config_names.values():
            if used_options.has_key(option):
                continue
            used_options[option] = None
            config_names.append((option.names[0], option))
        config_names.sort()
        if self._default_option:
            config_names.append((None, self._default_option[0]))
        result = []
        for name, option in config_names:
            result.append(option.ini_assignment(
                self, getattr(self, option.attr_name)))
        return ''.join(result)
    
class opt(object):

    default = NoDefault

    def __init__(self, names=None, **kw):
        self.names = names
        self.attr_name = None
        self.schema = None
        for name, value in kw.items():
            if not hasattr(self, name):
                raise TypeError(
                    "The keyword argument %s is unknown"
                    % name)
            setattr(self, name, value)

    def set_schema(self, schema):
        self.schema = schema

    def __get__(self, obj, type=None):
        if obj is None:
            return self
        try:
            return obj._ini_attrs[self.attr_name]
        except KeyError:
            if self.default is not NoDefault:
                return self.default
            raise AttributeError(
                "The attribute %s has not been set on %r"
                % (self.attr_name, obj))

    def __set__(self, obj, value):
        new_value = self.convert(obj, value)
        self.validate(obj, new_value)
        self.set_value(obj, new_value)

    def convert(self, obj, value):
        return value

    def validate(self, obj, value):
        pass

    def set_value(self, obj, value):
        obj._ini_attrs[self.attr_name] = value

    def __delete__(self, obj):
        try:
            del obj._ini_attrs[self.attr_name]
        except KeyError:
            raise AttributeError(
                "%r does not have an attribute %s"
                % (obj, self.attr_name))

    def ini_assignment(self, obj, value, name=None):
        if name is None:
            name = self.names[0]
        return '%s=%s\n' % (name,
                            self.ini_fold(self.ini_repr(obj, value)))

    def ini_fold(self, value):
        lines = value.splitlines()
        if len(lines) <= 1:
            return value
        lines = [lines[0]] + ['    ' + l for l in lines[1:]]
        return '\n'.join(lines)

    def ini_repr(self, obj, value):
        return str(value)
    
optstring = opt

class optint(opt):

    max = None
    min = None

    bad_type_message = "You must give an integer number, not %(value)r"
    too_large_message = "The value %(value)s is too large"
    too_small_message = "The value %(value)s is too small"
    coerce = int
    
    def convert(self, obj, value):
        try:
            new_value = self.coerce(value)
        except ValueError:
            raise ParseValueError(
                self.bad_type_message % {'value': value})
        if self.max is not None and new_value > self.max:
            raise ParseValueError(
                self.too_large_message % {'value': value})
        if self.min is not None and new_value < self.min:
            raise ParseValueError(
                self.too_small_message % {'value': value})
        return new_value

class optfloat(optint):
    
    coerce = float
    bad_type_message = "You must give a float number, not %(value)r"

class optbool(opt):

    true_values = ('yes', 'true', '1', 'on')
    false_values = ('no', 'false', '0', 'off')

    def convert(self, obj, value):
        if value.lower() in self.true_values:
            return True
        elif value.lower() in self.false_values:
            return False
        else:
            raise ParseValueError(
                "Should be a boolean value (true/false, on/off, yes/no), not %r"
                % value)

    def ini_repr(self, obj, value):
        if value:
            return 'true'
        else:
            return 'false'

class optlist(opt):

    subtype = opt

    def __init__(self, *args, **kw):
        opt.__init__(self, *args, **kw)
        if isinstance(self.subtype, type):
            self.subtype = self.subtype()

    def convert(self, obj, value):
        return self.subtype.convert(obj, value)

    def validate(self, obj, value):
        self.subtype.validate(obj, value)

    def set_value(self, obj, value):
        obj._ini_attrs.setdefault(self.attr_name, []).append(value)

    def ini_assignment(self, obj, value, name=None):
        if name is None:
            name = self.names[0]
        assert not isinstance(value, (str, unicode)), (
            "optlist attributes should receive lists or sequences, not "
            "strings (%r)" % value)
        all = [self.subtype.ini_assignment(obj, sub, name=name)
               for sub in value]
        return ''.join(all)

class optdefault(opt):

    allow_multiple = True

    def set_config_value(self, obj, name, value):
        if obj._default_values is None:
            obj._default_values = {}
        if self.allow_multiple:
            obj._default_values.setdefault(name, []).append(value)
        else:
            if obj._default_values.has_key(name):
                raise ParseValueError(
                    "You have already set the configuration key %r"
                    % name)
            obj._default_values[name] = value

    def __get__(self, obj, type=None):
        if obj is None:
            return self
        return obj._default_values or {}

    def __set__(self, obj, value):
        raise AttributeError(
            "The attribute %s cannot be set" % self.attr_name)

    def ini_assignment(self, obj, value, name=None):
        assert name is None, "default values can't accept a name"
        all = []
        all_values = self.__get__(obj).items()
        all_values.sort()
        for name, value in all_values:
            if isinstance(value, (str, unicode)):
                value = [value]
            for subvalue in value:
                all.append('%s=%s\n' % (
                    name, self.ini_fold(self.ini_repr(obj, subvalue))))
        return ''.join(all)

class optconverter(opt):

    misc_error_message = "%(error_type)s: %(message)s"
    converter_func = None

    def convert(self, obj, value):
        try:
            return self.converter_func(value)
        except Exception, e:
            raise ParseValueError(
                self.misc_error_message % {
                'message': str(e),
                'error_type': e.__class__.__name__})

    _converters = {}
    def get_converter(cls, name, converter_func):
        if cls._converters.has_key(id(converter_func)):
            return cls._converters[(name, id(converter_func))]
        else:
            converter = cls(name, converter_func=converter_func)
            cls._converters[(name, id(converter_func))] = converter
            return converter
    get_converter = classmethod(get_converter)

class SchemaINIParser(iniparser.INIParser):

    def __init__(self, schema):
        self.schema = schema

    def new_section(self, section):
        self.parse_error("Schemas do not yet support sections")

    def assignment(self, name, content):
        try:
            self.schema.set_config_value(name, content)
        except ParseValueError, e:
            self.parse_error(e.args[0])


Node-path: trunk/initools/lazyiniparser.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 5274
Text-content-md5: dc61dc2d1d15c2790311d6bd393efb5d
Text-content-sha1: ecb27606d4374ce8d4863f1f33fd37a0e57a0214
Content-length: 5284

PROPS-END
"""
A parser that keeps lots of information around, so the file can be
reconstructed almost exactly like it originally was entered.  Also, if
there are errors with values, they can be tracked back to a file and
line number.
"""

from iniparser import INIParser, ParseError

class ConversionError(Exception):
    pass

def canonical_name(name):
    return name.lower().replace(' ', '').replace('_', '')

class LazyINIParser(INIParser):

    def __init__(self, allow_empty_sections=False):
        self.allow_empty_sections = allow_empty_sections
        INIParser.__init__(self)

    def reset(self):
        self.configuration = Configuration()
        self.last_comment = []

    def add_comment(self, line):
        if line.startswith(' '):
            line = line[1:]
        self.last_comment.append(line)

    def assignment(self, name, content):
        item = Item(section=self.section,
                    name=name,
                    content=content,
                    comment='\n'.join(self.last_comment),
                    filename=self.filename,
                    lineno=self.start_lineno)
        self.last_comment = []
        if not self.section:
            self.new_section('')
        self.section.add_item(item)

    def new_section(self, section):
        if not section and not self.allow_empty_sections:
            self.error_no_section_name()
        self.section = Section(
            name=section.strip(),
            comment='\n'.join(self.last_comment))
        self.configuration.add_section(self.section)
        self.last_comment = []

class Configuration(object):

    def __init__(self):
        self.sections = []
        self.sections_by_name = {}

    def add_section(self, section):
        self.sections.append(section)
        # @@: I shouldn't be doing this here, I'll do it in lazyloader
        #names = self.split_names(section.name)
        #d = self.sections_by_name
        #for name in names[:-1]:
        #    d = d.setdefault(name, {})
        #d.setdefault(names[-1], []).append(section)

    def split_names(self, name):
        names = []
        while 1:
            dot_pos = name.find('.')
            paren_pos = name.find('(')
            if dot_pos == -1 and paren_pos == -1:
                next = canonical_name(name)
                if next:
                    names.append(next)
                return names
            if (dot_pos == -1 or (dot_pos > paren_pos
                                  and paren_pos != -1)):
                next = canonical_name(name[:paren_pos])
                if next:
                    names.append(next)
                name = name[paren_pos+1:]
                next_pos = name.find(')')
                assert next_pos != -1, (
                    "Bad section name, ) expected: %r" % name)
                names.append(name[:next_pos])
                name = name[next_pos+1:]
            else:
                assert dot_pos != -1
                assert paren_pos == -1 or dot_pos < paren_pos
                next = canonical_name(name[:dot_pos])
                assert next, (
                    "Empty name")
                names.append(next)
                name = name[dot_pos+1:]

    def source(self):
        return '\n\n'.join([s.source() for s in self.sections])

class Section(object):

    def __init__(self, name, comment):
        self.name = name
        self.comment = comment
        self.items = []
        self.canonical = {}

    def add_item(self, item):
        self.items.append(item)
        self.canonical.setdefault(
            canonical_name(item.name), []).append(item)

    def __repr__(self):
        return '<%s name=%r>' % (self.__class__.__name__, self.name)

    def source(self):
        s = ''
        if self.comment:
            s += '\n'.join(['# ' + l
                            for l in self.comment.splitlines()]) + '\n'
        s += '[%s]\n' % self.name
        s += ''.join([i.source() for i in self.items])
        return s


class Item(object):

    def __init__(self, section, name, content, comment,
                 filename, lineno):
        self.section = section
        self.name = name
        self.content = content
        self.comment = comment
        self.filename = filename
        self.lineno = lineno

    def value(self, name, converter=None, catch_all_exceptions=False):
        if catch_all_exceptions:
            ExcClass = Exception
        else:
            ExcClass = ConversionError
        if converter is not None:
            try:
                return converter(self.content)
            except ExcClass, e:
                msg = str(e)
                raise ParseError(
                    msg,
                    filename=self.filename,
                    lineno=self.lineno,
                    column=None)
        else:
            return self.content

    def __str__(self):
        return self.content

    def __repr__(self):
        return '<%s name=%r; value=%r>' % (
            self.__class__.__name__, self.name, self.content)

    def source(self):
        s = ''
        if self.comment:
            s += '\n'.join(['# ' + l
                            for l in self.comment.splitlines()]) + '\n'
        s += '%s = %s\n' % (self.name, self.content)
        return s


Node-path: trunk/initools/lazyloader.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 8574
Text-content-md5: c23ea97b801aaa674f1429b1e8a79cb2
Text-content-sha1: d15a0c94a0d86f0b028c48107bd8ca9869d5959b
Content-length: 8584

PROPS-END
"""
**Deprecated** (13 Aug 2006)

A config file loader that can load and nest multiple config files, the
config files can have structure, and the values can be tracked back to
their original file and line number.

To start, you'd do something like:

    >>> config = LazyLoader()

You could use ``.load(filename)`` to load a config file; for the
examples it is convenient to instead use loadstring, and give a fake
filename:

    >>> config_data = \"\"\"
    ... [server]
    ... port = 8000
    ... host = localhost
    ... document_root = /var/www
    ... \"\"\"
    >>> config.loadstring(config_data, filename='config_data.conf')
    >>> config['server']['port']
    '8000'
    >>> config['server'].convert('port', int)
    8000
    >>> config['server'].convert('host', int)
    Traceback (most recent call last):
        ...
    ValueError: Error in config_data.conf (section [server]), line 4 ('localhost'):
    ValueError: invalid literal for int(): localhost

Note that names are normalized, removing case, underscores, and
spaces.  So to get to the document root:

    >>> config['server']['documentroot']
    '/var/www'

You can also merge in values; for instance, consider a virtual host
that overrides global values:

    >>> vhost_data = \"\"\"
    ... [vhost(my.host.com)]
    ... document_root = /path/to/root
    ... \"\"\"
    >>> vhost_config = LazyLoader()
    >>> vhost_config.loadstring(vhost_data, filename='vhost_data.conf')
    >>> vhost_config['vhost'].keys()
    ['my.host.com']

Note that key and section names can be nested with .'s, and ()'s quote
the values (so the key is ['my.host.com'] instead of
['my']['host']['com']).  Then we may want to merge this in, based on a
condition (e.g., the hostname matches my.host.com):

    >>> config['server'].merge(vhost_config['vhost']['my.host.com'])
    >>> config['server']['documentroot']
    '/path/to/root'

"""

# This was deprecated 13 Aug 2006
import warnings
warnings.warn('initools.lazyloader is not supported or recommended for use.',
              DeprecationWarning)

from lazyiniparser import LazyINIParser, Item
from nested import NestedDict
import inischema
import re
from UserDict import UserDict, DictMixin

class LazyLoader(NestedDict):

    def __init__(self, configs=None, mutable=False, nest=True,
                 section_name=None, master=None):
        self.section_name = section_name
        self.master = master
        NestedDict.__init__(self, configs=configs, mutable=mutable,
                            nest=nest)
        
    def load(self, filename):
        parser = LazyINIParser(allow_empty_sections=True)
        parser.load(filename)
        config = self._convert_configuration(parser.configuration)
        self.add_config(config)

    def loadstring(self, s, filename=None):
        parser = LazyINIParser(allow_empty_sections=True)
        parser.loadstring(s, filename=filename)
        config = self._convert_configuration(parser.configuration)
        self.add_config(config)

    def merge(self, lazyloader):
        if self.master:
            self.master._propagate_merge([self.section_name], lazyloader)
        else:
            self._propagate_merge([], lazyloader)

    def _propagate_merge(self, slave_keys, lazyloader):
        if self.master:
            slave_keys.insert(0, self.section_name)
            self.master._propagate_merge(slave_keys, lazyloader)
        else:
            configs = filter(None, lazyloader.configs)
            new_configs = []
            for config in configs:
                if slave_keys:
                    new_config = {}
                    set_config = new_config
                    for key in slave_keys[:-1]:
                        set_config[key] = {}
                        set_config = set_config[key]
                    set_config[slave_keys[-1]] = config
                else:
                    new_config = config
                self.add_config(new_config)

    def __getitem__(self, key):
        try:
            return NestedDict.__getitem__(self, key)
        except KeyError, e:
            if self.section_name is None:
                section = 'global section'
            else:
                section = 'section [%s]' % self.section_name
            raise KeyError(
                "Key %r not found in %s" % (key, section))

    def _convert_configuration(self, conf):
        data = {}
        for section in conf.sections:
            section_keys = self._parse_keys(section.name)
            if section_keys == ['global']:
                section_keys = []
            for item in section.items:
                item_keys = self._parse_keys(item.name)
                all_keys = section_keys + item_keys
                pos = data
                for key in all_keys[:-1]:
                    pos = pos.setdefault(key, {})
                pos.setdefault(all_keys[-1], []).append(item)
        return data

    def _parse_keys(self, name):
        keys = []
        orig_name = name
        name = name.strip()
        while 1:
            next_period = name.find('.')
            next_paren = name.find('(')
            if next_paren == -1 and next_period == -1:
                next = self._canonical_name(name)
                if next:
                    keys.append(next)
                return keys
            elif (next_paren == -1
                or next_period != -1 and next_period < next_paren):
                next = self._canonical_name(name[:next_period])
                if next:
                    keys.append(next)
                name = name[next_period+1:]
            else:
                assert next_paren != -1
                assert next_period == -1 or next_paren < next_period
                next = self._canonical_name(name[:next_paren])
                if next:
                    keys.append(next)
                name = name[next_paren+1:]
                next_close = name.find(')')
                if next_close == -1:
                    raise inischema.ParseValueError(
                        "Key name contains a ( with no closing ): %r"
                        % orig_name)
                next = name[:next_close]
                keys.append(next)
                name = name[next_close+1:]

    _canonical_re = re.compile('[_ \t-]')
    def _canonical_name(self, name):
        return self._canonical_re.sub('', name.lower())

    def _convert_single(self, key, value_list):
        if isinstance(value_list[0], (dict, DictMixin, UserDict)):
            return self.__class__(
                value_list, mutable=self.mutable, nest=True,
                section_name=key, master=self)
        elif isinstance(value_list[0][-1], Item):
            return value_list[0][-1].content
        else:
            return value_list[0][-1]

    def getlist(self, key, add_inherited=True):
        results = self.raw_get(key, add_inherited=add_inherited)
        converted = []
        for result_set in results:
            if not isinstance(result_set, (list, tuple)):
                result_set = [result_set]
            for item in result_set:
                if isinstance(item, (dict, UserDict, DictMixin)):
                    value = self.__class__(
                        [item], mutable=self.mutable, nest=self.nest)
                elif isinstance(item, Item):
                    value = item.content
                else:
                    value = item
                converted.append(value)
        return converted

    def _make_converter(self, key, converter):
        if not isinstance(converter, inischema.opt):
            converter = inischema.optconverter.get_converter(
                key, converter_func=converter)
        return converter

    def convert(self, key, converter):
        converter = self._make_converter(key, converter)
        try:
            return converter.convert(None, self[key])
        except inischema.ParseValueError, e:
            item = self.raw_get(key)[0][0]
            message = ('Error in %s (section [%s]), line %i (%r):\n%s'
                       % (item.filename, item.section.name, item.lineno,
                          self[key], e))
            raise ValueError(message)

    def convertlist(self, key, converter, add_inherited=True):
        converter = self._make_converter(key, converter)
        value_list = self.getlist(key, add_inherited=add_inherited)
        new_list = []
        try:
            for value in value_list:
                new_list.append(converter.convert(value))
        except inischema.ParseValueError, e:
            pass
        
        


Node-path: trunk/initools/nested.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 5451
Text-content-md5: e926ac7502937552ccd75fa0a7e7b9c4
Text-content-sha1: fc50a98be9b7b0fa960a1750b25c780a455ad1db
Content-length: 5461

PROPS-END
"""
**Deprecated** (13 Aug 2006)

Layers multiple dictionaries.

Nested dictionaries can be traversed, with each dictionary shadowing
the previous dictionaries.  So for example:

    >>> d = NestedDict([{'foo': 'bar'}])
    >>> d['foo']
    'bar'
    >>> d2 = d.clone(add_dict={'foo': 'bar2'})
    >>> d2['foo']
    'bar2'
    >>> d2.getlist('foo')
    ['bar2', 'bar']

This works for deeply nested dictionaries, not just at the top level;
each nested dictionary gets wrapped in a NestedDict as well.
"""

# This was deprecated 13 Aug 2006
import warnings
warnings.warn('initools.nested is not supported or recommended for use.',
              DeprecationWarning)

from UserDict import DictMixin, UserDict

class NestedDict(DictMixin):

    def __init__(self, configs=None, mutable=True, nest=True):
        if configs is None:
            configs = [{}]
        assert isinstance(configs, (list, tuple)), (
            "The configs must be a list or tuple, not: %r"
            % configs)
        self.configs = configs
        self.mutable = mutable
        self.nest = nest

    def __getitem__(self, key):
        results = self.raw_get(key)
        if not results:
            raise KeyError, "Key not found: %r" % key
        return self._convert_single(key, results)

    def add_config(self, config, position=0):
        assert not isinstance(config, (str, unicode)), (
            "Bad configuration (not a mapping): %r" % config)
        if position is None:
            self.configs.append(config)
        else:
            self.configs.insert(position, config)

    def set_configs(self, new_configs):
        self.configs[:] = []
        for config in new_configs:
            self.add_config(config, None)

    def raw_get(self, key, add_inherited=True):
        results = []
        if add_inherited:
            all_configs = self.configs
        else:
            all_configs = [self.configs[-1]]
        for config in all_configs:
            if key in config:
                if isinstance(config, (str, unicode)):
                    print [key, config, all_configs, self.configs]
                results.append(config[key])
        return results

    def getlist(self, key, add_inherited=True):
        results = self.raw_get(key, add_inherited=add_inherited)
        converted = []
        for result_set in results:
            if not isinstance(result_set, (list, tuple)):
                result_set = [result_set]
            converted.extend(self._convert_many(key, result_set))
        return converted

    def _convert_single(self, key, value_list):
        if (not self.nest
            or not isinstance(value_list[0],
                              (dict, DictMixin, UserDict))):
            # @@: doesn't handle all dict alternatives
            return value_list[0]
        elif len(value_list) == 1 and self.mutable:
            return value_list[0]
        else:
            return self.__class__(
                value_list, mutable=self.mutable, nest=True)

    def _convert_many(self, key, value_list):
        return [self._convert_single(key, [v]) for v in value_list]

    def __setitem__(self, key, value):
        if self.mutable:
            self.configs[0][key] = value
        else:
            raise KeyError, (
                "Dictionary is read-only")

    def __delitem__(self, key):
        if not self.mutable:
            raise KeyError, (
                "Dictionary is read-only")
        if self.configs[0].has_key(key):
            del self.configs[0][key]
        elif self.has_key(key):
            raise KeyError, (
                "You cannot delete the key %r, as it belongs to the "
                "a master configuration %r"
                % (key, self.master))
        else:
            raise KeyError, (
                "Key does not exist: %r" % key)

    def keys(self):
        return list(self)

    def __contains__(self, key):
        for config in self.configs:
            if config.has_key(key):
                return True
        return False

    def has_key(self, key):
        return key in self

    def __iter__(self):
        used = {}
        for config in self.configs:
            for key in config:
                if key in used:
                    continue
                used[key] = None
                yield key

    _clone_sentry = []

    def clone(self, add_dict=None, mutable=_clone_sentry,
              nest=_clone_sentry):
        if mutable is self._clone_sentry:
            mutable = self.mutable
        if nest is self._clone_sentry:
            nest = self.nest
        new = self.configs[:]
        if add_dict is not None:
            new.insert(0, add_dict)
        else:
            new.insert(0, {})
        return self.__class__(new, mutable=mutable, nest=nest)

    def copy(self):
        return dict(self.iteritems())

    def __eq__(self, other):
        if other is None:
            return False
        if (not hasattr(other, 'keys')
            or not hasattr(other, '__getitem__')):
            return False
        for key in other:
            if not key in self:
                return False
        for name, value in self.iteritems():
            if other[name] != value:
                return False
        return True

    def __cmp__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return '<%s %r>' % (self.__class__.__name__,
                            dict(self.iteritems()))


Revision-number: 6
Prop-content-length: 126
Content-length: 126

K 7
svn:log
V 27
explained to where we moved
K 10
svn:author
V 4
hugo
K 8
svn:date
V 27
2010-07-02T01:25:32.063276Z
PROPS-END

Node-path: trunk/README-moved.txt
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 229
Text-content-md5: d7ab70932a224dfcd3a431c96457cdac
Text-content-sha1: 9e1f799beda5a57c9a3889c1c65ed017834662c1
Content-length: 239

PROPS-END
Development no longer occurs in this repository

Please see:

  http://bitbucket.org/ianb/initools

Check out with:

  hg clone http://bitbucket.org/ianb/initools

Download from:

  http://bitbucket.org/ianb/initools/get/tip.gz



Revision-number: 7
Prop-content-length: 151
Content-length: 151

K 7
svn:log
V 52
added regen-docs script to generate docs and publish
K 10
svn:author
V 4
hugo
K 8
svn:date
V 27
2010-07-02T01:25:54.204853Z
PROPS-END

Node-path: trunk/regen-docs
Node-kind: file
Node-action: add
Prop-content-length: 36
Text-content-length: 243
Text-content-md5: bfe187c9fe1ac35f62690e1149fda840
Text-content-sha1: c2d072e334debcf4ce3aa8c11cc86692d19dc863
Content-length: 279

K 14
svn:executable
V 1
*
PROPS-END
#!/bin/sh

mkdir -p docs/_static docs/_build
sphinx-build -E -b html docs/ docs/_build || exit 1
if [ "$1" = "publish" ] ; then
  cd docs/
  echo "Uploading files..."
  scp -r _build/* ianb@webwareforpython.org:/home/paste/htdocs/initools/
fi


Revision-number: 8
Prop-content-length: 118
Content-length: 118

K 7
svn:log
V 19
added missing files
K 10
svn:author
V 4
hugo
K 8
svn:date
V 27
2010-07-02T01:26:38.319358Z
PROPS-END

Node-path: trunk/setup.cfg
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 674
Text-content-md5: ce4082f072e1efecb9e6ad9b6fc3a5af
Text-content-sha1: a97ad8b8ae02573d62bb1a15814154d9b4da1915
Content-length: 684

PROPS-END
[egg_info]
tag_build = dev
tag_svn_revision = true

[global]
command_packages = buildutils.pudge_command, buildutils.publish_command

[pudge]
theme = pythonpaste.org
docs = docs/index.txt
doc_base = docs/
dest = docs/html
modules = initools
title = INITools
organization = Python Paste
organization_url = http://pythonpaste.org/
mailing_list_url = /community/mailing-list.html
trac_url = http://trac.pythonpaste.org/
settings = no_about=true
           link1=/download/ http://svn.colorstudy.com/INITools/trunk
highlighter = pygments

[publish]
doc-dir=docs/html
doc-dest=scp://ianb@webwareforpython.org/home/paste/htdocs/initools
make-dirs=1

[stats]
extra-packages=tests



Node-path: trunk/setup.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 925
Text-content-md5: 78bae916558667352bac7a1d827c88dd
Text-content-sha1: a0fa90cffb78d9a313d8963dc4a845cadcffe685
Content-length: 935

PROPS-END
from setuptools import setup, find_packages

version = '0.3.1'

setup(name='INITools',
      version=version,
      description="Tools for parsing and using INI-style files",
      long_description="""\
A set of tools for parsing and using ``.ini``-style files, including
an abstract parser and several tools built on that parser.

Repository available at `http://svn.colorstudy.com/INITools/trunk
<http://svn.colorstudy.com/INITools/trunk#egg=INITools-dev>`_
""",
      classifiers=[
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Topic :: Software Development :: Libraries",
        ],
      url="http://pythonpaste.org/initools/",
      keywords="config parser ini",
      author="Ian Bicking",
      author_email="ianb@colorstudy.com",
      license="MIT",
      packages=find_packages(exclude=['ez_setup', 'examples', 'tests']),
      zip_safe=True,
      )
      


Node-path: trunk/tests
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Node-path: trunk/tests/cfgparser.1
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 21
Text-content-md5: 091fa766089a86ee582c8bad29644b46
Text-content-sha1: 240162cdf19ac185e0150d922d766a5000faa634
Content-length: 31

PROPS-END
[Foo Bar]
foo=newbar


Node-path: trunk/tests/conftest.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 133
Text-content-md5: a5a603bb3e86ac2a1b2a3ee0e997a49d
Text-content-sha1: d72ce053fc385d545ed96af9b84d3eca6a16c5cf
Content-length: 143

PROPS-END
import sys, os
sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))
import pkg_resources
pkg_resources.require('INITools')


Node-path: trunk/tests/test_cfgparser.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 18536
Text-content-md5: dae825f7835f784acc1b1a3f8971ed8c
Text-content-sha1: f6961d56d162757cd4c035e257bed6f5a73d1f28
Content-length: 18546

PROPS-END
import os, sys
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from initools import configparser as ConfigParser
import StringIO
import unittest

#from test import test_support


class BaseCase(unittest.TestCase):
    def newconfig(self, defaults=None):
        if defaults is None:
            self.cf = self.config_class()
        else:
            self.cf = self.config_class(defaults)
        return self.cf

    def fromstring(self, string, defaults=None, filename=None):
        cf = self.newconfig(defaults)
        sio = StringIO.StringIO(string)
        cf.readfp(sio, filename=filename)
        return cf

    def test_basic(self):
        cf = self.fromstring(
            "[Foo Bar]\n"
            "foo=bar\n"
            "[Spacey Bar]\n"
            "foo = bar\n"
            "[Commented Bar]\n"
            "foo: bar ; comment\n"
            "[Long Line]\n"
            "foo: this line is much, much longer than my editor\n"
            "   likes it.\n"
            "[Section\\with$weird%characters[\t]\n"
            "[Internationalized Stuff]\n"
            "foo[bg]: Bulgarian\n"
            "foo=Default\n"
            "foo[en]=English\n"
            "foo[de]=Deutsch\n"
            "[Spaces]\n"
            "key with spaces : value\n"
            "another with spaces = splat!\n"
            )
        L = cf.sections()
        L.sort()
        eq = self.assertEqual
        eq(L, [
            r'Commented Bar',
            r'Foo Bar',
            r'Internationalized Stuff',
            r'Long Line',
            r'Section\with$weird%characters[' '\t',
            r'Spaces',
            r'Spacey Bar',
            ])

        # The use of spaces in the section names serves as a
        # regression test for SourceForge bug #583248:
        # http://www.python.org/sf/583248
        eq(cf.get('Foo Bar', 'foo'), 'bar')
        eq(cf.get('Spacey Bar', 'foo'), 'bar')
        eq(cf.get('Commented Bar', 'foo'), 'bar')
        eq(cf.get('Spaces', 'key with spaces'), 'value')
        eq(cf.get('Spaces', 'another with spaces'), 'splat!')

        self.failIf('__name__' in cf.options("Foo Bar"),
                    '__name__ "option" should not be exposed by the API!')

        # Make sure the right things happen for remove_option();
        # added to include check for SourceForge bug #123324:
        self.failUnless(cf.remove_option('Foo Bar', 'foo'),
                        "remove_option() failed to report existance of option")
        self.failIf(cf.has_option('Foo Bar', 'foo'),
                    "remove_option() failed to remove option")
        self.failIf(cf.remove_option('Foo Bar', 'foo'),
                    "remove_option() failed to report non-existance of option"
                    " that was removed")

        self.assertRaises(ConfigParser.NoSectionError,
                          cf.remove_option, 'No Such Section', 'foo')

        eq(cf.get('Long Line', 'foo'),
           'this line is much, much longer than my editor\nlikes it.')

    def test_case_sensitivity(self):
        cf = self.newconfig()
        cf.add_section("A")
        cf.add_section("a")
        L = cf.sections()
        L.sort()
        eq = self.assertEqual
        eq(L, ["A", "a"])
        cf.set("a", "B", "value")
        # @@: Modified because we are case-insensitive
        # but case-preserving
        eq(cf.options("a"), ["B"])
        eq(cf.get("a", "b"), "value",
           "could not locate option, expecting case-insensitive option names")
        self.failUnless(cf.has_option("a", "b"))
        cf.set("A", "A-B", "A-B value")
        for opt in ("a-b", "A-b", "a-B", "A-B"):
            self.failUnless(
                cf.has_option("A", opt),
                "has_option() returned false for option which should exist")
        # @@: Modified for case-preserving:
        eq(cf.options("A"), ["A-B"])
        # @@: Modified for case-preserving:
        eq(cf.options("a"), ["B"])
        cf.remove_option("a", "B")
        eq(cf.options("a"), [])

        # SF bug #432369:
        cf = self.fromstring(
            "[MySection]\nOption: first line\n\tsecond line\n")
        eq(cf.options("MySection"), ["Option"])
        # @@: Modified for case-preserving:
        eq(cf.get("MySection", "Option"), "first line\nsecond line")

        # SF bug #561822:
        cf = self.fromstring("[section]\nnekey=nevalue\n",
                             defaults={"key":"value"})
        self.failUnless(cf.has_option("section", "Key"))


    def test_default_case_sensitivity(self):
        cf = self.newconfig({"foo": "Bar"})
        self.assertEqual(
            cf.get("DEFAULT", "Foo"), "Bar",
            "could not locate option, expecting case-insensitive option names")
        cf = self.newconfig({"Foo": "Bar"})
        self.assertEqual(
            cf.get("DEFAULT", "Foo"), "Bar",
            "could not locate option, expecting case-insensitive defaults")

    def test_parse_errors(self):
        self.newconfig()
        self.parse_error(ConfigParser.ParsingError,
                         "[Foo]\n  extra-spaces: splat\n")
        self.parse_error(ConfigParser.ParsingError,
                         "[Foo]\n  extra-spaces= splat\n")
        self.parse_error(ConfigParser.ParsingError,
                         "[Foo]\noption-without-value\n")
        self.parse_error(ConfigParser.ParsingError,
                         "[Foo]\n:value-without-option-name\n")
        self.parse_error(ConfigParser.ParsingError,
                         "[Foo]\n=value-without-option-name\n")
        # @@: This used to be just 'No Section!', but that gets
        # raised as an error early on because it doesn't look like
        # an assignment.
        self.parse_error(ConfigParser.MissingSectionHeaderError,
                         "No Section=null\n")

    def parse_error(self, exc, src):
        sio = StringIO.StringIO(src)
        try:
            self.cf.readfp(sio)
        except exc:
            pass
        else:
            assert 0, "Not raised %s: got %s" % (exc, self.cf.allitems())
        #self.assertRaises(exc, self.cf.readfp, sio)

    def test_query_errors(self):
        cf = self.newconfig()
        self.assertEqual(cf.sections(), [],
                         "new ConfigParser should have no defined sections")
        self.failIf(cf.has_section("Foo"),
                    "new ConfigParser should have no acknowledged sections")
        self.assertRaises(ConfigParser.NoSectionError,
                          cf.options, "Foo")
        self.assertRaises(ConfigParser.NoSectionError,
                          cf.set, "foo", "bar", "value")
        self.get_error(ConfigParser.NoSectionError, "foo", "bar")
        cf.add_section("foo")
        self.get_error(ConfigParser.NoOptionError, "foo", "bar")

    def get_error(self, exc, section, option):
        try:
            self.cf.get(section, option)
        except exc, e:
            return e
        else:
            self.fail("expected exception type %s.%s"
                      % (exc.__module__, exc.__name__))

    def test_boolean(self):
        cf = self.fromstring(
            "[BOOLTEST]\n"
            "T1=1\n"
            "T2=TRUE\n"
            "T3=True\n"
            "T4=oN\n"
            "T5=yes\n"
            "F1=0\n"
            "F2=FALSE\n"
            "F3=False\n"
            "F4=oFF\n"
            "F5=nO\n"
            "E1=2\n"
            "E2=foo\n"
            "E3=-1\n"
            "E4=0.1\n"
            "E5=FALSE AND MORE"
            )
        for x in range(1, 5):
            self.failUnless(cf.getboolean('BOOLTEST', 't%d' % x))
            self.failIf(cf.getboolean('BOOLTEST', 'f%d' % x))
            self.assertRaises(ValueError,
                              cf.getboolean, 'BOOLTEST', 'e%d' % x)

    def test_weird_errors(self):
        cf = self.newconfig()
        cf.add_section("Foo")
        self.assertRaises(ConfigParser.DuplicateSectionError,
                          cf.add_section, "Foo")

    def test_write(self):
        cf = self.fromstring(
            "[Long Line]\n"
            "foo: this line is much, much longer than my editor\n"
            "   likes it.\n"
            "[DEFAULT]\n"
            "foo: another very\n"
            " long line"
            )
        output = StringIO.StringIO()
        cf.write(output)
        self.assertEqual(
            output.getvalue(),
            "[DEFAULT]\n"
            "foo = another very\n"
            "\tlong line\n"
            "\n"
            "[Long Line]\n"
            "foo = this line is much, much longer than my editor\n"
            "\tlikes it.\n"
            "\n"
            )

    def test_write_multiline(self):
        cf = self.fromstring(
            "[test]\n"
            "snippet = one line\n"
            "  two; line\n"
            "  three line\n"
            "snippet2 = empty\n"
            )
        output = StringIO.StringIO()
        cf.write(output)
        self.assertEqual(
            output.getvalue(),
            "[DEFAULT]\n\n"
            "[test]\n"
            "; line\n"
            "snippet = one line\n"
            "\ttwo\n"
            "\tthree line\n\n"
            "snippet2 = empty\n\n"
            )

    def test_write_sources(self):
        cf = self.fromstring(
            "[main]\n"
            "setting1 = foo\n"
            "setting2 = bar\n",
            filename="file1.ini")
        cf.set('main', 'setting2', 'BAR', filename='file2.ini')
        cf.set('main', 'setting3', 'XYZ', filename='file3.ini')
        output = StringIO.StringIO()
        cf.write_sources(output, ['file1.ini'])
        self.assertEqual(
            output.getvalue(),
            "[main]\n"
            "setting1 = foo\n\n")
        output = StringIO.StringIO()
        cf.write_sources(output, ['file1.ini', 'file2.ini'])
        self.assertEqual(
            output.getvalue(),
            "[main]\n"
            "setting1 = foo\n"
            "setting2 = BAR\n\n")

    def test_set_string_types(self):
        cf = self.fromstring("[sect]\n"
                             "option1=foo\n")
        # Check that we don't get an exception when setting values in
        # an existing section using strings:
        class mystr(str):
            pass
        cf.set("sect", "option1", "splat")
        cf.set("sect", "option1", mystr("splat"))
        cf.set("sect", "option2", "splat")
        cf.set("sect", "option2", mystr("splat"))
        try:
            unicode
        except NameError:
            pass
        else:
            cf.set("sect", "option1", unicode("splat"))
            cf.set("sect", "option2", unicode("splat"))

    def test_read_returns_file_list(self):
        file1 = os.path.join(os.path.dirname(__file__), 'cfgparser.1')
        # check when we pass a mix of readable and non-readable files:
        cf = self.newconfig()
        parsed_files = cf.read([file1, "nonexistant-file"])
        self.assertEqual(parsed_files, [file1])
        self.assertEqual(cf.get("Foo Bar", "foo"), "newbar")
        # check when we pass only a filename:
        cf = self.newconfig()
        parsed_files = cf.read(file1)
        self.assertEqual(parsed_files, [file1])
        self.assertEqual(cf.get("Foo Bar", "foo"), "newbar")
        # check when we pass only missing files:
        cf = self.newconfig()
        parsed_files = cf.read(["nonexistant-file"])
        self.assertEqual(parsed_files, [])
        # check when we pass no files:
        cf = self.newconfig()
        parsed_files = cf.read([])
        self.assertEqual(parsed_files, [])

    # shared by subclasses
    def get_interpolation_config(self):
        return self.fromstring(
            "[Foo]\n"
            "bar=something %(with1)s interpolation (1 step)\n"
            "bar9=something %(with9)s lots of interpolation (9 steps)\n"
            "bar10=something %(with10)s lots of interpolation (10 steps)\n"
            "bar11=something %(with11)s lots of interpolation (11 steps)\n"
            "with11=%(with10)s\n"
            "with10=%(with9)s\n"
            "with9=%(with8)s\n"
            "with8=%(With7)s\n"
            "with7=%(WITH6)s\n"
            "with6=%(with5)s\n"
            "With5=%(with4)s\n"
            "WITH4=%(with3)s\n"
            "with3=%(with2)s\n"
            "with2=%(with1)s\n"
            "with1=with\n"
            "\n"
            "[Mutual Recursion]\n"
            "foo=%(bar)s\n"
            "bar=%(foo)s\n"
            "\n"
            "[Interpolation Error]\n"
            "name=%(reference)s\n",
            # no definition for 'reference'
            defaults={"getname": "%(__name__)s"})

    def check_items_config(self, expected):
        cf = self.fromstring(
            "[section]\n"
            "name = value\n"
            "key: |%(name)s| \n"
            "getdefault: |%(default)s|\n"
            "getname: |%(__name__)s|",
            defaults={"default": "<default>"})
        L = list(cf.items("section"))
        self.assertEqual(L, expected)


class ConfigParserTestCase(BaseCase):
    config_class = ConfigParser.ConfigParser

    def test_interpolation(self):
        cf = self.get_interpolation_config()
        eq = self.assertEqual
        eq(cf.get("Foo", "getname"), "Foo")
        eq(cf.get("Foo", "bar"), "something with interpolation (1 step)")
        eq(cf.get("Foo", "bar9"),
           "something with lots of interpolation (9 steps)")
        eq(cf.get("Foo", "bar10"),
           "something with lots of interpolation (10 steps)")
        self.get_error(ConfigParser.InterpolationDepthError, "Foo", "bar11")

    def test_interpolation_missing_value(self):
        cf = self.get_interpolation_config()
        e = self.get_error(ConfigParser.InterpolationError,
                           "Interpolation Error", "name")
        self.assertEqual(e.reference, "reference")
        self.assertEqual(e.section, "Interpolation Error")
        self.assertEqual(e.option, "name")

    def test_items(self):
        # @@: Ordered to match original source
        self.check_items_config([
            ('name', 'value'),
            ('key', '|value|'),
            ('getdefault', '|<default>|'),
            ('getname', '|section|'),
            ('default', '<default>'),
            ])

    def test_set_nonstring_types(self):
        cf = self.newconfig()
        cf.add_section('non-string')
        cf.set('non-string', 'int', 1)
        cf.set('non-string', 'list', [0, 1, 1, 2, 3, 5, 8, 13, '%('])
        cf.set('non-string', 'dict', {'pi': 3.14159, '%(': 1,
                                      '%(list)': '%(list)'})
        cf.set('non-string', 'string_with_interpolation', '%(list)s')
        self.assertEqual(cf.get('non-string', 'int', raw=True), 1)
        self.assertRaises(TypeError, cf.get, 'non-string', 'int')
        self.assertEqual(cf.get('non-string', 'list', raw=True),
                         [0, 1, 1, 2, 3, 5, 8, 13, '%('])
        self.assertRaises(TypeError, cf.get, 'non-string', 'list')
        self.assertEqual(cf.get('non-string', 'dict', raw=True),
                         {'pi': 3.14159, '%(': 1, '%(list)': '%(list)'})
        self.assertRaises(TypeError, cf.get, 'non-string', 'dict')
        self.assertEqual(cf.get('non-string', 'string_with_interpolation',
                                raw=True), '%(list)s')
        # @@: This originally raise ValueError, instead of TypeError
        # I can't figure out why that'd be true
        self.assertRaises(TypeError, cf.get, 'non-string',
                          'string_with_interpolation', raw=False)


class RawConfigParserTestCase(BaseCase):
    config_class = ConfigParser.RawConfigParser

    def test_interpolation(self):
        cf = self.get_interpolation_config()
        eq = self.assertEqual
        eq(cf.get("Foo", "getname"), "%(__name__)s")
        eq(cf.get("Foo", "bar"),
           "something %(with1)s interpolation (1 step)")
        eq(cf.get("Foo", "bar9"),
           "something %(with9)s lots of interpolation (9 steps)")
        eq(cf.get("Foo", "bar10"),
           "something %(with10)s lots of interpolation (10 steps)")
        eq(cf.get("Foo", "bar11"),
           "something %(with11)s lots of interpolation (11 steps)")

    def test_items(self):
        # @@: Ordered to match original source
        self.check_items_config([
            ('name', 'value'),
            ('key', '|%(name)s|'),
            ('getdefault', '|%(default)s|'),
            ('getname', '|%(__name__)s|'),
            ('default', '<default>'),
            ])

    def test_set_nonstring_types(self):
        cf = self.newconfig()
        cf.add_section('non-string')
        cf.set('non-string', 'int', 1)
        cf.set('non-string', 'list', [0, 1, 1, 2, 3, 5, 8, 13])
        cf.set('non-string', 'dict', {'pi': 3.14159})
        self.assertEqual(cf.get('non-string', 'int'), 1)
        self.assertEqual(cf.get('non-string', 'list'),
                         [0, 1, 1, 2, 3, 5, 8, 13])
        self.assertEqual(cf.get('non-string', 'dict'), {'pi': 3.14159})


class SafeConfigParserTestCase(ConfigParserTestCase):
    config_class = ConfigParser.SafeConfigParser

    def test_safe_interpolation(self):
        # See http://www.python.org/sf/511737
        cf = self.fromstring("[section]\n"
                             "option1=xxx\n"
                             "option2=%(option1)s/xxx\n"
                             "ok=%(option1)s/%%s\n"
                             "not_ok=%(option2)s/%%s")
        self.assertEqual(cf.get("section", "ok"), "xxx/%s")
        self.assertEqual(cf.get("section", "not_ok"), "xxx/xxx/%s")

    def test_set_nonstring_types(self):
        cf = self.fromstring("[sect]\n"
                             "option1=foo\n")
        # Check that we get a TypeError when setting non-string values
        # in an existing section:
        self.assertRaises(TypeError, cf.set, "sect", "option1", 1)
        self.assertRaises(TypeError, cf.set, "sect", "option1", 1.0)
        self.assertRaises(TypeError, cf.set, "sect", "option1", object())
        self.assertRaises(TypeError, cf.set, "sect", "option2", 1)
        self.assertRaises(TypeError, cf.set, "sect", "option2", 1.0)
        self.assertRaises(TypeError, cf.set, "sect", "option2", object())

del BaseCase

#def test_main():
#    test_support.run_unittest(
#        ConfigParserTestCase,
#        RawConfigParserTestCase,
#        SafeConfigParserTestCase
#    )

if __name__ == "__main__":
    import unittest
    # To keep it from being tested
    unittest.main()
    #test_main()


Node-path: trunk/tests/test_iniparser.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 1471
Text-content-md5: ff792646dc3d512a59a72700b2b07be5
Text-content-sha1: 5f8f6c0bb89ec543efed9357f34b3b21146a5f5d
Content-length: 1481

PROPS-END
from initools import iniparser
import re

def parse(s, filename='test.ini'):
    p = iniparser.BasicParser()
    p.loadstring(s, filename=filename)
    return p

def raises(sample, match):
    if isinstance(match, str):
        match = re.compile(match)
    try:
        parse(sample)
    except iniparser.ParseError, e:
        if match and not match.search(str(e)):
            raise
    else:
        assert 0, "Parsing %r should have raised an error" % sample

def test_no_section():
    raises(
        """# A file...
a=10
""", r'^Assignments can only.*')
        
def test_no_equal():
    raises(
        """[a file]
this is a test
""", r'^Lines should look like.*')

def test_bad_section():
    raises(
        """[file
""", r'^Invalid section.*')

def test_empty_section():
    raises(
        """[]
""", r'^Empty section name.*')

def test_equal_colon():
    sec = parse("""[test]
a=1:2
b: 1=3""").data['test']
    assert sec['a'] == ['1:2']
    assert sec['b'] == ['1=3']

def test_multi_section():
    data = parse("""[test]
#a=1
a=2
a=3
a=4
[test2]
a=1
""").data
    assert data['test']['a'] == ['2', '3', '4']
    assert data['test2']['a'] == ['1']

def test_continuation():
    data = parse("""[test]
a = a
   pretty
 bird
\tb=3
b=another
  line
[test2]
[test3]
c=[blah]
  [blah]""").data
    assert data['test']['a'] == ['a\npretty\nbird\nb=3']
    assert data['test']['b'] == ['another\nline']
    assert data['test3']['c'] == ['[blah]\n[blah]']
        


Node-path: trunk/tests/test_inischema.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 2229
Text-content-md5: 9dc4501ed3a64c584bb3f347035c2a89
Text-content-sha1: fd07ef2a4c9d047c2c40139040dd56ccff9ef814
Content-length: 2239

PROPS-END
from initools.inischema import *

class Schema1(INISchema):
    
    number = optint()
    maybe = optbool(names=['maybe', 'or not'])
    float = optfloat()
    string = opt()
    string2 = opt()
    rep = optlist(subtype=optint())
    whatever = opt(default=5)

class Schema2(INISchema):

    a = optint()
    default = optdefault()

class Schema3(Schema2):
    pass
Schema3.add_option('default', optdefault(allow_multiple=False))
Schema3.add_option('b', optlist(subtype=optint()))

def parse_schema(schema, string, filename='test.ini'):
    if not isinstance(schema, INISchema):
        schema = schema()
    schema.loadstring(string)
    return schema

load_ini = """
number = 1
float = 1
or not = true
string = something
string2=something
rep=1
rep=5
rep=10
"""

def test_load():
    s = parse_schema(Schema1, load_ini)
    assert s.as_dict() == {
        'number': 1,
        'maybe': True,
        'float': 1.0,
        'string': 'something',
        'string2': 'something',
        'rep': [1, 5, 10]}
    assert s.number == 1
    assert s.rep == [1, 5, 10]
    assert s.whatever == 5
    assert s.string == 'something'

def test_unload():
    s = parse_schema(Schema1, load_ini)
    assert s.ini_repr() == """\
float=1.0
maybe=true
number=1
rep=1
rep=5
rep=10
string=something
string2=something
whatever=5
"""
                         

default_ini = """
a = 1
b = 2
c = 3
"""

def test_default():
    s = parse_schema(Schema2, default_ini)
    assert s.as_dict() == {
        'a': 1,
        'default': {'b': ['2'],
                    'c': ['3']}}
    assert s.as_dict(fold_defaults=True) == {
        'a': 1,
        'b': ['2'],
        'c': ['3']}

def test_default2():
    s = parse_schema(Schema3, default_ini)
    assert s.as_dict() == {
        'a': 1,
        'b': [2],
        'default': {'c': '3'}}
    assert s.as_dict(fold_defaults=True) == {
        'a': 1, 'b': [2], 'c': '3'}

def test_gen():
    s = parse_schema(Schema2, default_ini)
    assert s.ini_repr() == "a=1\nb=2\nc=3\n"
    s.a = 2
    assert s.ini_repr() == "a=2\nb=2\nc=3\n"

def test_gen2():
    s = parse_schema(Schema3, default_ini)
    assert s.ini_repr() == "a=1\nb=2\nc=3\n"
    s.a = 2
    assert s.ini_repr() == "a=2\nb=2\nc=3\n"
    


Node-path: trunk/tests/test_lazyiniparser.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 593
Text-content-md5: 0b8e2df0e786d76bd3cd2a9411ac6e3d
Text-content-sha1: 4a5c2cc71ac6d1210ecb4889c526fc1877eb1607
Content-length: 603

PROPS-END
from initools import lazyiniparser

def parse(s, filename='test.ini'):
    p = lazyiniparser.LazyINIParser()
    p.loadstring(s, filename=filename)
    return p.configuration


data = """\
# a test
[section 1]
a = 2
a2 = 3
# one more...
a = 4
"""

def test_simple():
    c = parse(data)
    assert len(c.sections) == 1
    assert c.sections[0].name == 'section 1'
    assert c.sections[0].comment == 'a test'
    items = c.sections[0].items
    assert [i.name for i in items] == ['a', 'a2', 'a']
    assert [i.lineno for i in items] == [3, 4, 6]
    assert c.source() == data
        
       


Node-path: trunk/tests/test_lazyloader.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 3151
Text-content-md5: 49848d35fe755364f53d9cf287901ba7
Text-content-sha1: 84af48a724ede3ef6f50322934ac3bee6e7c0825
Content-length: 3161

PROPS-END
from initools import lazyloader
import py.test

# @@: Should also test docstrings

data1 = """\
[ages]

jeanette = 72
dave = 54

[children]

jeanette = dave
dave = ian
dave = monica
"""

try:
    sorted
except NameError:
    def sorted(v):
        v = list(v)
        v.sort()
        return v

def test_create():
    config = lazyloader.LazyLoader()
    config.loadstring(data1, filename="data1.conf")
    assert sorted(config.keys()) == ['ages', 'children']
    assert config['ages']['jeanette'] == '72'
    assert config['ages']['dave'] == '54'
    assert config['children']['dave'] == 'monica'
    assert config['children']['jeanette'] == 'dave'
    assert config['children'].getlist('dave') == ['ian', 'monica']
    assert config['ages'].convert('jeanette', int) == 72
    py.test.raises(
        ValueError,
        config['children'].convert, 'jeanette', int)
    py.test.raises(
        KeyError,
        config['children'].convert, 'joe', str)
    py.test.raises(
        KeyError,
        config.__getitem__, 'child')
    
data2 = """\
[children]
# Another child...
jeanette = mary
"""

def test_fold():
    config = lazyloader.LazyLoader()
    config.loadstring(data1, filename="data1.conf")
    config.loadstring(data2, filename="data2.conf")
    assert config['children']['jeanette'] == 'mary'
    assert (sorted(config['children'].getlist('jeanette'))
            == ['dave', 'mary'])
    assert config['children']['dave'] == 'monica'
    assert sorted(config.keys()) == ['ages', 'children']
    assert sorted(config['children'].keys()) == ['dave', 'jeanette']

data3 = """\
children.mary = vada
[global]
children.mary = armen
"""

data4 = """\
george = chelsea
"""

data5 = """\
[something(here!)]
test.this.out = foo
"""

def test_global():
    config = lazyloader.LazyLoader()
    config.loadstring(data1, filename="data1.conf")
    config.loadstring(data2, filename="data2.conf")
    config.loadstring(data3, filename="data3.conf")
    assert config['children']['mary'] == 'armen'
    assert config['children'].getlist('mary') == ['vada', 'armen']
    merged = lazyloader.LazyLoader()
    merged.loadstring(data4, filename="data4.conf")
    config['children'].merge(merged)
    assert config['children']['george'] == 'chelsea'
    config.merge(merged)
    assert config['george'] == 'chelsea'
    merge2 = lazyloader.LazyLoader()
    merge2.loadstring(data5, filename="data5.conf")
    assert merge2['something']['here!']['test']['this']['out'] == 'foo'
    config.merge(merge2)
    assert config['something']['here!']['test']['this']['out'] == 'foo'
    


def parse_keys(n):
    p = lazyloader.LazyLoader()
    return p._parse_keys(n)

def test_parse_section():
    data = [
        ('a', 'a'),
        ('a.b', 'a', 'b'),
        ('this  . that', 'this', 'that'),
        ('this...that', 'this', 'that'),
        ('foo_bar(foo_bar)', 'foobar', 'foo_bar'),
        ('A.(B).C', 'a', 'B', 'c'),
        ('A(B)C', 'a', 'B', 'c'),
        ('a ( b ) . c . d . ( e )', 'a', ' b ', 'c', 'd', ' e '),
        ]
    for trial in data:
        input = trial[0]
        output = list(trial[1:])
        assert parse_keys(input) == output
    


Node-path: trunk/tests/test_nested.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 1357
Text-content-md5: 91c2ff7fac0269975db09daab63d4a4c
Text-content-sha1: c424bccee52aadd6bfad7069ced06ada37ca394e
Content-length: 1367

PROPS-END
from initools import nested
NestedDict = nested.NestedDict
from pprint import pprint

def sorted(l):
    l = l[:]
    l.sort()
    return l

def test_empty():
    d = NestedDict()
    d['a'] = 1
    assert d['a'] == 1
    d['a'] = 2
    assert d['a'] == 2
    src = {'c': 2}
    d['b'] = src
    assert d['b'] == src
    assert d['b'] is src
    assert d['b']['c'] == 2
    d2 = d.clone()
    assert d == d2
    d2['a'] = 3
    assert d.items() != d2.items()
    assert list(d.iteritems()) != list(d2.iteritems())
    print list(d.iteritems()), list(d2.iteritems())
    print d.configs, d2.configs
    assert d != d2
    assert repr(d) != repr(d2)
    assert d2['a'] == 3
    d3 = d.copy()
    assert d == d3
    assert d != None
    assert d != []
    assert d != object()

def test_nested():
    src = {
        'a': 1,
        'b': {
        'c': 2,
        'd': 3,
        }}
    shadow = {
        'b': {
        'c': 5,
        'e': 6,
        }}
    d = NestedDict([shadow, src])
    assert d['a'] == 1
    assert d['b']['c'] == 5
    assert d['b']['d'] == 3
    assert sorted(d.keys()) == ['a', 'b']
    assert sorted(d['b'].keys()) == ['c', 'd', 'e']
    assert isinstance(d['b'], NestedDict)
    concrete = {'a': 1, 'b': {'c': 5, 'd': 3, 'e': 6}}
    pprint(d)
    pprint(concrete)
    assert d == concrete

# @@: Should test docstrings in nested


Revision-number: 9
Prop-content-length: 117
Content-length: 117

K 7
svn:log
V 18
added foo file :-)
K 10
svn:author
V 4
hugo
K 8
svn:date
V 27
2010-07-02T01:27:09.341908Z
PROPS-END

Node-path: trunk/foo
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 4
Text-content-md5: d3b07384d113edec49eaa6238ad5ff00
Text-content-sha1: f1d2d2f924e986ac86fdf7b36c94bcdf32beec15
Content-length: 14

PROPS-END
foo


Revision-number: 10
Prop-content-length: 106
Content-length: 106

K 7
svn:log
V 8
lol file
K 10
svn:author
V 4
hugo
K 8
svn:date
V 27
2010-07-02T01:27:23.484029Z
PROPS-END

Node-path: trunk/lol
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 4
Text-content-md5: 59bcc3ad6775562f845953cf01624225
Text-content-sha1: 6d96270004515a0486bb7f76196a72b40c55a47f
Content-length: 14

PROPS-END
lol


Revision-number: 11
Prop-content-length: 115
Content-length: 115

K 7
svn:log
V 16
removed setup.py
K 10
svn:author
V 4
hugo
K 8
svn:date
V 27
2010-07-02T01:27:37.629418Z
PROPS-END

Node-path: trunk/setup.py
Node-action: delete


Revision-number: 12
Prop-content-length: 116
Content-length: 116

K 7
svn:log
V 17
removed setup.cfg
K 10
svn:author
V 4
hugo
K 8
svn:date
V 27
2010-07-02T01:27:53.076796Z
PROPS-END

Node-path: trunk/setup.cfg
Node-action: delete


Revision-number: 13
Prop-content-length: 119
Content-length: 119

K 7
svn:log
V 20
added empty setup.py
K 10
svn:author
V 4
hugo
K 8
svn:date
V 27
2010-07-02T01:29:23.296806Z
PROPS-END

Node-path: trunk/setup.py
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 0
Text-content-md5: d41d8cd98f00b204e9800998ecf8427e
Text-content-sha1: da39a3ee5e6b4b0d3255bfef95601890afd80709
Content-length: 10

PROPS-END


Revision-number: 14
Prop-content-length: 120
Content-length: 120

K 7
svn:log
V 21
added empty setup.cfg
K 10
svn:author
V 4
hugo
K 8
svn:date
V 27
2010-07-02T01:29:51.527789Z
PROPS-END

Node-path: trunk/setup.cfg
Node-kind: file
Node-action: add
Prop-content-length: 10
Text-content-length: 0
Text-content-md5: d41d8cd98f00b204e9800998ecf8427e
Text-content-sha1: da39a3ee5e6b4b0d3255bfef95601890afd80709
Content-length: 10

PROPS-END


Node-path: trunk/setup.py
Node-kind: file
Node-action: change
Text-content-length: 925
Text-content-md5: 78bae916558667352bac7a1d827c88dd
Text-content-sha1: a0fa90cffb78d9a313d8963dc4a845cadcffe685
Content-length: 925

from setuptools import setup, find_packages

version = '0.3.1'

setup(name='INITools',
      version=version,
      description="Tools for parsing and using INI-style files",
      long_description="""\
A set of tools for parsing and using ``.ini``-style files, including
an abstract parser and several tools built on that parser.

Repository available at `http://svn.colorstudy.com/INITools/trunk
<http://svn.colorstudy.com/INITools/trunk#egg=INITools-dev>`_
""",
      classifiers=[
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Topic :: Software Development :: Libraries",
        ],
      url="http://pythonpaste.org/initools/",
      keywords="config parser ini",
      author="Ian Bicking",
      author_email="ianb@colorstudy.com",
      license="MIT",
      packages=find_packages(exclude=['ez_setup', 'examples', 'tests']),
      zip_safe=True,
      )
      


Revision-number: 15
Prop-content-length: 119
Content-length: 119

K 7
svn:log
V 20
added back setup.cfg
K 10
svn:author
V 4
hugo
K 8
svn:date
V 27
2010-07-02T01:30:17.584489Z
PROPS-END

Node-path: trunk/setup.cfg
Node-kind: file
Node-action: change
Text-content-length: 674
Text-content-md5: ce4082f072e1efecb9e6ad9b6fc3a5af
Text-content-sha1: a97ad8b8ae02573d62bb1a15814154d9b4da1915
Content-length: 674

[egg_info]
tag_build = dev
tag_svn_revision = true

[global]
command_packages = buildutils.pudge_command, buildutils.publish_command

[pudge]
theme = pythonpaste.org
docs = docs/index.txt
doc_base = docs/
dest = docs/html
modules = initools
title = INITools
organization = Python Paste
organization_url = http://pythonpaste.org/
mailing_list_url = /community/mailing-list.html
trac_url = http://trac.pythonpaste.org/
settings = no_about=true
           link1=/download/ http://svn.colorstudy.com/INITools/trunk
highlighter = pygments

[publish]
doc-dir=docs/html
doc-dest=scp://ianb@webwareforpython.org/home/paste/htdocs/initools
make-dirs=1

[stats]
extra-packages=tests



